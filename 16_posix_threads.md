# POSIX Threads (Pthreads)

## 1. Что такое pthreads

Pthreads — стандарт POSIX для многопоточного программирования. Он
определяет API создания, управления и синхронизации потоков в
UNIX‑подобных ОС. Типичная функция потока имеет сигнатуру
`void* (*)(void*)` и должна возвращать значение, которое сможет прочесть
`pthread_join`.

Ключевые возможности:

-   `pthread_create` — запуск потока с заданной функцией и аргументом;
-   `pthread_join` / `pthread_detach` — ожидание завершения или перевод в
    «безожиданный» режим, чтобы не копить зомби-потоки;
-   примитивы синхронизации (`pthread_mutex_*`, `pthread_cond_*`,
    `pthread_rwlock_*`, `sem_*` и др.; подробнее в билете про
    синхронизацию);
-   поток-локальные данные (`pthread_key_*`);
-   настройка атрибутов (`pthread_attr_*`).

Все потоки процесса делят адресное пространство и ресурсы процесса
(дескрипторы, сигнал-блокировки, память), поэтому любая разделяемая
структура требует аккуратной синхронизации.

---

## 2. Жизненный цикл потока

1.  **Создание** — `pthread_create` получает адрес функции, аргумент и
    атрибуты (размер стека, детач-состояние и т. д.).
2.  **Работа** — поток исполняет функцию параллельно с другими.
3.  **Завершение** — возврат из функции, `pthread_exit` или отмена через
    `pthread_cancel`.
4.  **Сборка ресурсов** — `pthread_join` забирает код возврата и
    освобождает внутренние структуры ядра. Для детач-потоков сборка
    происходит автоматически, но их нельзя дождаться.

Если забыть `join` для joinable-потока, останется «висящая» запись
потока и потенциальная утечка ресурсов.

---

## 3. Атрибуты потоков

-   `pthread_attr_setstack` / `_stacksize` — указать свой буфер стека или
    изменить размер.
-   `pthread_attr_setguardsize` — защитное «красное» пространство для
    ловли переполнения стека.
-   `pthread_attr_setdetachstate` — создать сразу детач-поток.
-   Планирование: `pthread_setschedparam` / `pthread_attr_setschedpolicy`
    задают политику (`SCHED_OTHER`, `FIFO`, `RR`) и приоритет (требуют
    прав).
-   Привязка к CPU делается отдельными функциями `pthread_setaffinity_np`
    (не часть базового POSIX, но часто нужна).

---

## 4. Отмена и точки отмены

`pthread_cancel` посылает запрос отмены. По умолчанию отмена **отложена**
и срабатывает в «точках отмены» (`pthread_testcancel`, большинство
блокирующих вызовов: `read`, `pthread_cond_wait`, `sleep` и др.).

-   `pthread_setcancelstate` — включить/выключить обработку отмены.
-   `pthread_setcanceltype` — отложенная (`PTHREAD_CANCEL_DEFERRED`) или
    асинхронная (`PTHREAD_CANCEL_ASYNCHRONOUS`, опаснее).
-   `pthread_cleanup_push/pop` — зарегистрировать обработчики очистки,
    чтобы освободить ресурсы при отмене.

---

## 5. Поток-локальное хранилище (TLS)

Когда нужно хранить данные на поток, а не глобально:

1.  `pthread_key_create(&key, destructor)` — создаёт ключ; `destructor`
    вызывается при выходе потока, если значение ненулевое.
2.  `pthread_setspecific(key, value)` / `pthread_getspecific(key)` —
    запись и чтение значения.
3.  `pthread_key_delete(key)` — удаление ключа, когда он больше не нужен.

Используется для логгеров, соединений БД, буферов без блокировок между
потоками.

---

## 6. Примитивы синхронизации в pthreads (кратко)

-   Мьютексы: обычные, рекурсивные, с приоритетным наследованием.
-   Условные переменные: ожидание событий с разблокировкой мьютекса.
-   RW-lock: разделяемое чтение и эксклюзивная запись.
-   Семафоры POSIX (`sem_t`), спинлоки (`pthread_spin_*`).
-   Барьеры (`pthread_barrier_*` в расширениях).
Подробнее про паттерны использования — см. билет про синхронизацию.

---

## 7. Пример: создание и ожидание потока

``` c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void* thread_func(void* arg) {
    const char* msg = (const char*)arg;
    printf("Worker: %s\n", msg);
    return (void*)42; // код возврата
}

int main() {
    pthread_t thread;
    if (pthread_create(&thread, NULL, thread_func, (void*)"hello") != 0) {
        perror("pthread_create");
        return 1;
    }

    void* retval = NULL;
    if (pthread_join(thread, &retval) != 0) {
        perror("pthread_join");
        return 1;
    }

    printf("Thread exit code: %ld\n", (long)retval);
    return 0;
}
```
