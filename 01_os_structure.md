# Структура операционной системы, цели и задачи

## Зачем нужна ОС
- Абстракция оборудования: скрывает детали CPU, памяти, дисков, сетей за стабильными интерфейсами.
- Управление ресурсами: планирует, кому и когда выдавать CPU, память, файлы, сетевые сокеты.
- Упрощение разработки: предоставляет системные вызовы, драйверную модель, стандартные API.
- Изоляция и защита: предотвращает взаимное влияние процессов, обеспечивает контроль доступа.
- Производительность и справедливость: балансирует скорость отклика (interactive) и пропускную способность (batch).

## Базовые компоненты
- Ядро (kernel): выполняется в привилегированном режиме, реализует диспетчеризацию процессов, управление памятью, файловые системы, драйверы.
- Пространство пользователя: процессы и службы, взаимодействующие с ядром через системные вызовы.
- Диспетчер процессов: создает, планирует, завершает процессы и потоки; поддерживает состояния ready/running/blocked.
- Управление памятью: виртуальная память, страничная организация, политики замещения (LRU, CLOCK), защита страниц.
- Файловые системы: абстракция именованных объектов, каталоги, права; журнальные (ext4, XFS), копирующие при записи (Btrfs, ZFS).
- Ввод‑вывод: драйверы, буферизация, очереди, прерывания; стек блокирующего/неблокирующего I/O.
- Механизмы IPC: каналы, очереди сообщений, сокеты, общая память, futex/семафоры/мониторы.

## Архитектурные модели (по Таненбауму и др.)

### Монолитное ядро
- Суть: почти все основные подсистемы ОС выполняются в одном привилегированном адресном пространстве:
  - планировщик и управление процессами;
  - управление памятью;
  - файловые системы и блоковый слой;
  - сетевой стек;
  - драйверы устройств.
- Взаимодействие между подсистемами — обычные вызовы функций внутри ядра, без перехода через механизм сообщений.
- Современные монолиты (Linux, *BSD) как правило модульные: часть функциональности загружается как LKM (Loadable Kernel Module), но с точки зрения защиты всё равно работает в том же режиме ядра.
- Плюсы:
  - высокая производительность: минимальные накладные расходы на переходы между компонентами;
  - проще реализовать сложные оптимизации, проходящие через несколько подсистем (например, взаимодействие планировщика диска и файловой системы);
  - драйверы могут напрямую пользоваться внутренними структурами данных ядра.
- Минусы:
  - ошибки в драйвере или файловой системе легко приводят к краху всей системы (kernel panic);
  - сложнее строго формально проверить корректность и безопасность всего объёма кода;
  - большие и тесно связанные подсистемы — высокая сложность сопровождения.
- Примеры:
  - классические Unix‑системы, Linux, FreeBSD/OpenBSD/NetBSD;
  - многие RTOS для встраиваемых систем.

### Микроядро
- Идея: максимально «вынести» функциональность из привилегированного режима. В ядре остаётся только минимальный набор:
  - планирование потоков;
  - базовое управление адресными пространствами и диспетчеризация страниц;
  - механизм межпроцессного взаимодействия (IPC: сообщения, порты, каналы);
  - обработка прерываний и минимальная часть диспетчеризации устройств.
- Всё остальное (файловые системы, стек TCP/IP, драйверы, менеджер процессов высокого уровня, сервер имен и т.п.) выполняется в пользовательском пространстве в виде отдельных серверов.
- Модель работы:
  - приложение обращается к серверу (например, файловому) через IPC, ядро лишь пересылает сообщения и переключает контекст;
  - сервер, в свою очередь, может перепоручать работу другим серверам (сетевому, дисковому).
- Плюсы:
  - высокая изоляция и надёжность: падение драйвера или файлового сервера не рушит ядро; можно перезапустить компонент;
  - более чёткие интерфейсы между компонентами, проще формальная верификация (seL4);
  - гибкая конфигурация: разные наборы серверов для разных систем (встраиваемые, десктоп, экспериментальные).
- Минусы:
  - накладные расходы на IPC и частые переключения контекста между ядром и пользовательскими серверами;
  - сложность реализации высокопроизводительных операций ввода‑вывода и кеширования в такой модели;
  - в реальных системах приходится идти на компромиссы (часть сервисов «просачивается» обратно в ядро).
- Примеры:
  - Minix 3 (Таненбаум), QNX, семейство L4 (seL4, Fiasco и др.), исторически Mach;
  - в учебной литературе микрокернелы часто приводятся как «идеальная» модель для надёжности.

### Гибридное ядро
- Это компромисс между микро‑ и монолитной архитектурой:
  - из микроядра берётся идея модульности и чётких интерфейсов;
  - из монолита — размещение большинства подсистем всё же в режиме ядра ради производительности.
- Логически система может быть организована как набор подсистем и серверов, но физически многие из них работают в одном привилегированном адресном пространстве.
- Примеры:
  - Windows NT: микрокернел NT + «executive» (объектный менеджер, I/O менеджер, кеш‑менеджер, диспетчер безопасности и др.), работающие в kernel mode;
  - XNU (macOS, iOS): ядро основано на Mach, но значительная часть BSD‑подсистемы и драйверов выполняется в режиме ядра.
- Плюсы:
  - лучше контролируемая архитектура, чем классический «спаянный» монолит;
  - возможность частично использовать преимущества микроядра (разделение ответственности, модульность) без больших потерь по скорости.
- Минусы:
  - многие риски монолита сохраняются (ошибка драйвера в kernel mode всё ещё критична);
  - модель получается сложной, трудно строго классифицировать и анализировать.

### Слоистая модель
- Концептуальная модель, подчёркивающая уровни абстракции:
  - уровень 0: железо (CPU, память, контроллеры шин, устройства);
  - уровень 1: ядро и драйверы (управление процессами, памятью, прерываниями, базовый I/O);
  - уровень 2: системные службы (демоны, серверы оконной системы, сетевые службы);
  - уровень 3: библиотеки и языковые рантаймы (glibc, JVM, интерпретаторы);
  - уровень 4: пользовательские приложения.
- В строгих слоистых ОС каждый уровень обращается только к соседним, что упрощает доказательство корректности и локализацию ошибок.
- На практике строгая иерархия часто нарушается ради скорости (драйвер может обращаться к «нижним» уровням напрямую), но сама модель полезна для понимания структуры ОС и для учебных систем.

### Клиент‑серверная модель в ОС
- В общем виде: большинство функциональности ОС (службы, демоны) представляются как серверы, а приложения — как клиенты.
- Ядро предоставляет базовые примитивы для:
  - передачи сообщений (сокеты, очереди сообщений, порты);
  - синхронизации (семафоры, мьютексы, мониторы);
  - контроля прав доступа (разрешения, capabilities, MAC‑политики).
- Примеры:
  - файловый сервер, оконный сервер, сервер аутентификации — отдельные процессы или набор процессов, с которыми приложения общаются через IPC;
  - оконные системы X11/Wayland очень наглядно демонстрируют клиент‑серверный подход в пользовательском пространстве.
- Такая модель может сочетаться как с монолитным ядром (Linux + X11/Wayland, systemd‑сервисы), так и с микроядром (Minix/QNX, где серверы находятся в user space и частично заменяют функциональность ядра).

## Цели проектирования

Таненбаум выделяет три базовые цели операционной системы: сделать работу пользователя удобнее (convenience), обеспечить эффективное использование аппаратных ресурсов (efficiency) и позволить системе развиваться вместе с техникой и требованиями (ability to evolve). На практике к ним добавляются инженерные требования к надежности, безопасности и модульности.

### Удобство (convenience)
- ОС должна скрывать низкоуровневые детали работы железа и предоставлять привычные абстракции:
  - файлы и каталоги вместо сырых блоков диска;
  - процессы и потоки вместо прямого управления регистрами CPU;
  - сетевые сокеты и имена хостов вместо работы с MAC‑адресами и кадрами.
- Для пользователя важны:
  - единообразный интерфейс (командная строка, системные вызовы POSIX, графическая оболочка);
  - привычное поведение утилит, возможность автоматизировать работу скриптами;
  - прозрачная многозадачность: пользователь ощущает, что «всё работает параллельно».
- Для программиста удобство означает:
  - наличие стабильных API и ABI;
  - богатый набор библиотек и инструментов (отладчики, профилировщики);
  - предсказуемая модель ошибок и исключений.

### Эффективное использование ресурсов (efficiency)
- Одна из ключевых задач ОС — максимально загрузить процессор, память, диски, сеть, не жертвуя при этом интерактивностью.
- ОС решает, кому и когда выдавать:
  - CPU (планировщик процессов и потоков);
  - оперативную память (аллокаторы, виртуальная память, свопинг);
  - дисковый и сетевой ввод‑вывод (очереди запросов, приоритезация, кеширование).
- Важно не только «выжать максимум» из железа, но и сделать это справедливо:
  - интерактивные задачи (терминал, GUI) должны получать отклик за миллисекунды;
  - длительные вычисления и фоновые задания — не голодать (отсутствие starvation).
- Примеры механизмов:
  - планировщики CFS, BFS, Completely Fair Scheduler в Linux;
  - I/O‑планировщики mq-deadline, bfq;
  - техники zero‑copy I/O, NUMA‑осведомлённое распределение памяти.

### Эволюционность (ability to evolve)
- ОС должна приспосабливаться к новым типам оборудования и новым сценариям использования:
  - появление многоядерных и NUMA‑систем;
  - новые классы устройств (смартфоны, IoT, облака, контейнеры);
  - новые протоколы и стандарты (IPv6, шифрование, виртуализация).
- Для этого архитектура ОС должна:
  - иметь чётко определённые интерфейсы между слоями (ядро ↔ драйверы, ядро ↔ файловые системы, ядро ↔ пользовательские службы);
  - поддерживать модульность (драйверы и подсистемы, загружаемые динамически);
  - соблюдать обратную совместимость, насколько это возможно.
- Примеры:
  - подсистема модулей ядра Linux (LKM), позволяющая добавлять драйверы без пересборки ядра;
  - виртуальные файловые системы (VFS), через которые можно подключать новые FS, не переписывая пользовательские программы;
  - слои абстракции железа (HAL) в Windows и встраиваемых ОС.

### Надежность и устойчивость
- Надёжность (reliability) означает, что система выполняет свои функции длительно и корректно, даже при частичных сбоях железа и программ.
- Устойчивость (robustness) — способность ОС адекватно реагировать на ошибки:
  - некорректные запросы приложений;
  - отсутствие ответов от устройства;
  - повреждение данных на носителе.
- Типичные механизмы:
  - изоляция процессов в отдельных адресных пространствах;
  - защита памяти, запрет доступа к ядру из user‑space;
  - использование журналируемых файловых систем (ext4, XFS) для снижения риска потери данных при сбое питания;
  - watchdog‑таймеры и механизмы перезагрузки зависших подсистем.

### Безопасность
- В многопользовательских и сетевых системах безопасность — одна из центральных целей.
- ОС должна обеспечивать:
  - аутентификацию пользователей и сервисов (учетные записи, Kerberos, сертификаты);
  - авторизацию — назначение прав доступа к файлам, устройствам и IPC‑объектам (Unix‑права, ACL, capabilities);
  - аудит — журналирование действий, изменений конфигурации, попыток взлома;
  - изоляцию процессов и контейнеров (адресное пространство, user/mount/net namespaces, cgroups).
- Модели контроля доступа:
  - DAC (discretionary): классические владельцы и группы в Unix;
  - MAC (mandatory): SELinux, AppArmor, SMACK;
  - ролевая модель (RBAC) и capability‑подход на уровне ядра.

### Портируемость
- Портируемая ОС может быть собрана и запущена на разных архитектурах (x86, ARM, RISC‑V, Power и т.п.).
- Для этого:
  - вводится слой абстракции над аппаратными особенностями (HAL, machine‑dependent layer);
  - максимально возможная часть ядра и служб пишется на переносимом языке (обычно C);
  - используются стандартизованные интерфейсы (POSIX, SUS).
- Портируемость важна как для коммерческих, так и для исследовательских систем: позволяет использовать один и тот же код на серверах, встраиваемых платформах и десктопах.

### Расширяемость и модульность
- ОС должна позволять добавлять новые функции без полной её переборки:
  - загрузка и выгрузка модулей ядра (драйверы устройств, новые файловые системы, сетевые протоколы);
  - возможность внедрения новых системных вызовов и hook‑ов;
  - плагинные архитектуры в пользовательском пространстве (модули Apache/Nginx, PAM‑модули).
- Модульность облегчает:
  - сопровождение (обновляется только нужный компонент);
  - разработку (разные команды могут работать над независимыми подсистемами);
  - создание специализированных конфигураций (минимальное ядро для встраиваемых систем, полное — для серверов).

## Типичные задачи ядра

Ядро — центральная часть ОС, работающая в привилегированном режиме. Его задачи можно рассматривать как конкретизацию перечисленных выше целей: оно обеспечивает управляемый доступ к ресурсам, изоляцию и эффективную работу процессов.

### Планирование и управление процессами
- Планирование (scheduling) — выбор, какой поток/процесс будет выполняться на CPU в данный момент.
- Основные элементы:
  - модель процессов и потоков (PID, дескриптор процесса, состояния ready/running/blocked/zombie);
  - очереди готовых к выполнению задач и тех, кто ждёт события (ожидание I/O, таймера, сигнала);
  - политики планирования: для интерактивных, batch‑ и real‑time задач.
- Цели планировщика:
  - обеспечить приемлемое время отклика интерактивных приложений;
  - не допускать голодания низкоприоритетных задач;
  - эффективно использовать несколько ядер (SMP) и NUMA‑узлы.
- Примеры:
  - CFS (Completely Fair Scheduler) в Linux, использующий «виртуальное время» и красно‑чёрные деревья;
  - планировщики реального времени (SCHED_FIFO, SCHED_RR).

### Синхронизация и конкуренция
- На многопроцессорных системах разные потоки могут параллельно обращаться к общим данным, что ведёт к гонкам (race conditions).
- Ядро предоставляет и использует примитивы синхронизации:
  - мьютексы, спинлоки, read‑write‑блокировки;
  - семафоры, условные переменные;
  - специальные структуры типа seqlock, RCU (Read‑Copy‑Update) для высоконагруженных путей.
- Задачи:
  - защитить критические секции;
  - минимизировать ожидание и contention;
  - избегать взаимоблокировок (deadlock) и инверсии приоритетов (priority inversion).

### Управление памятью
- Ядро отвечает за предоставление каждому процессу иллюзии собственного непрерывного адресного пространства (виртуальная память).
- Основные функции:
  - управление страницами памяти (paging): отображение виртуальных адресов в физические через таблицы страниц и MMU;
  - выделение и освобождение памяти ядру и процессам (slab/slub‑аллокаторы, buddy‑аллокатор);
  - свопинг/paging‑out: выгрузка редко используемых страниц на диск для освобождения RAM;
  - поддержка больших страниц (huge pages) для снижения накладных расходов.
- Ядро также реализует механизмы `mmap/munmap`, copy‑on‑write при `fork`, и защиты страниц (read‑only, no‑exec), что тесно связано с безопасностью.

### Управление устройствами и подсистема ввода‑вывода
- Ядро инкапсулирует детали работы с конкретными устройствами в драйверах:
  - драйверы шины (PCI/USB/I²C/SPI) отвечают рза обнаружение устройств и базовую конфигурацию;
  - драйверы конкретных устройств (диски, сетевые карты, видеокарты, датчики) предоставляют унифицированный интерфейс в виде файлов, сетевых интерфейсов, устройств ввода.
- Подсистема ввода‑вывода:
  - обрабатывает прерывания от устройств;
  - настраивает DMA для эффективной передачи блоков данных;
  - реализует буферизацию и кеширование (кеш страничек диска, очереди запросов к дискам и сетевым адаптерам).
- Сюда же относится управление энергопотреблением (ACPI, Runtime PM), hotplug/горячее подключение устройств (PCIe hotplug, USB).

### Файловые системы и блочный слой
- ОС представляет данные пользователю в виде иерархии файлов и каталогов, независимо от того, на каком физическом носителе они лежат.
- Файловая подсистема ядра включает:
  - VFS (Virtual File System) — абстрактный слой, через который разные файловые системы (ext4, XFS, Btrfs, NFS) выглядят одинаково;
  - блочный слой (block layer) — унифицированный интерфейс для блочных устройств (HDD, SSD, RAID, виртуальные диски);
  - page cache — кеш страниц файлов в памяти для ускорения чтения и записи.
- Файловые системы реализуют:
  - структуру каталогов и метаданные (права, владельцы, временные метки);
  - механизмы обеспечения целостности (журналирование, copy‑on‑write, снапшоты);
  - специальные возможности (квоты, ACL, extended attributes).

### Сетевая подсистема
- Ядро реализует сетевой стек, который скрывает от приложений детали работы с протоколами и сетевыми устройствами.
- Основные функции:
  - поддержка протоколов уровня IP (IPv4/IPv6), транспортных протоколов (TCP, UDP, SCTP), а также множества прикладных протоколов через модули;
  - маршрутизация пакетов, NAT, фильтрация и файрвол (Netfilter/iptables/nftables);
  - управление сетевыми интерфейсами (Ethernet, Wi‑Fi, виртуальные интерфейсы, туннели).
- Для приложений сетевой стек выглядит как работа с сокетами: они читают и пишут байтовые потоки, а ядро разбивает их на пакеты, гарантирует доставку (TCP) или быстрый безгарантийный обмен (UDP).

## Аппаратные шины и путь от датчика до приложения
- Системные шины:
  - **Front‑side/системная шина, QPI, Infinity Fabric** — соединяют CPU, контроллер памяти, иногда другие кристаллы.
  - **PCI/PCI Express** — основная шина для «больших» устройств: видеокарта, сетевые карты, контроллеры NVMe/SATA, USB‑контроллеры.
  - **Агрегирующие шины SoC** (AMBA: AHB/AXI/APB и др.) — внутри систем‑на‑кристалле (ARM, мобильные SoC) соединяют ядра, контроллеры и периферию.
- Периферийные шины:
  - **USB** — универсальная последовательная шина для внешних устройств: клавиатура, мышь, флешки, веб‑камеры, модемы, аудио‑интерфейсы.
  - **SATA/SAS/NVMe** — подключение дисков и SSD; NVMe работает поверх PCIe и предоставляет очереди запросов ядру.
  - **I²C, SPI** — типичные шины для датчиков (температуры, давления, акселерометры, гироскопы), EEPROM, небольших АЦП/ЦАП в встраиваемых системах.
  - **UART/RS‑232/RS‑485** — последовательные интерфейсы для модемов, промышленных датчиков, контроллеров, консольной диагностики.
  - **CAN, LIN, FlexRay** — полевые шины в автомобилях и промышленной автоматике (датчики, блоки управления).
- Роль ОС в работе с шинами:
  - Инициализирует контроллеры шин (PCI host bridge, USB host controller, I²C master и т.п.), сканирует и перечисляет устройства (enumeration).
  - Назначает адресное пространство (MMIO/IO‑port), IRQ, MSI/MSI‑X, настраивает DMA, чтобы устройства могли напрямую работать с памятью.
  - Загружает и связывает драйверы с конкретными устройствами по идентификаторам (VendorID/DeviceID для PCI, классы для USB, адреса для I²C).
  - Предоставляет унифицированный интерфейс в пространство пользователя: файловые узлы (`/dev/input/*`, `/dev/sda`, `/dev/tty*`), сетевые интерфейсы (`eth0`, `wlan0`), абстракции типа `hwmon` для датчиков.
- Типичный путь «датчик → приложение»:
  1) Датчик (например, температурный или акселерометр) подключен по I²C/SPI/UART/CAN к контроллеру на плате или в SoC.
  2) Контроллер шины генерирует прерывания или готовит данные по запросу драйвера, используя DMA/регистры.
  3) Ядро через драйвер шины и драйвер конкретного датчика читает «сырые» значения, может применить калибровку/масштабирование.
  4) Драйвер экспортирует данные через стандартный интерфейс: `sysfs` (`/sys/class/hwmon/...`), `input`‑субсистему (`/dev/input/event*`), `industrial I/O (IIO)` или специализированное символьное устройство.
  5) Пользовательское приложение (демон мониторинга, GUI, логгер) читает данные через файловые дескрипторы, ioctl или библиотеку и уже реализует бизнес‑логику (показать температуру, скорректировать обороты вентилятора, включить аварийный режим и т.п.).

## Источники
- Таненбаум, Бос. «Современные операционные системы».
- Stallings. «Operating Systems: Internals and Design Principles».
- Love. «Linux Kernel Development».
