# Select/poll — мотивация и принципы работы

## 1. Контекст: ввод-вывод и блокирующие дескрипторы

Во многих задачах (сетевые серверы, чаты, прокси, системы мониторинга) программа должна:
- одновременно работать с **несколькими источниками ввода-вывода**:
  - несколькими сокетами;
  - файлами, pipe'ами;
  - терминалами и т.д.;
- своевременно реагировать на события:
  - пришли данные от клиента;
  - можно отправить данные, не блокируясь;
  - соединение закрыто и т.п.

### 1.1. Блокирующий ввод-вывод

По умолчанию системные вызовы:
- `read()`, `recv()`, `accept()`, `connect()` и др.
работают в **блокирующем режиме**:

- если данных нет — `read()` блокирует поток до появления данных;
- если нет входящих соединений — `accept()` блокирует поток;
- `connect()` ждёт установления соединения или тайм-аута.

Это удобно для простых программ, но **плохо масштабируется**, если нужно:
- обслуживать много клиентов;
- работать с множеством дескрипторов.

---

## 2. Мотивация появления select/poll

### 2.1. Наивные подходы

Есть два простых варианта:

1. **Один процесс/поток на клиента**
   - для каждого сокета:
     - отдельный процесс/поток, который блокируется на `read()`/`recv()`;
   - проблемы:
     - накладные расходы на создание и переключение контекстов;
     - сложность синхронизации;
     - плохая масштабируемость (сотни/тысячи клиентов).

2. **Неблокирующие сокеты и активный опрос (busy waiting)**
   - перевести дескрипторы в неблокирующий режим (`O_NONBLOCK`);
   - в цикле:
     - пробовать `read()`/`recv()` на каждом сокете;
     - если данных нет — продолжать;
   - проблемы:
     - цикл «крутится» постоянно, загружая процессор;
     - приходится вручную опрашивать все дескрипторы.

### 2.2. Что хотелось бы

Нужен механизм, который позволит:
- **одному потоку** ждать **событий сразу на множестве дескрипторов**;
- **блокироваться до тех пор**, пока:
  - на каком-либо дескрипторе не появятся данные для чтения;
  - какой-либо дескриптор не станет готов к записи;
  - не произойдёт исключительная ситуация (ошибка, закрытие и т.п.);
  - не истечёт тайм-аут.

Идея:
- пусть ядро само «наблюдает» за дескрипторами;
- когда что-то случится — разбудит процесс, сообщив, какие дескрипторы готовы.

Для этого и были введены механизмы **мультиплексирования ввода-вывода**:
- `select()`;
- `poll()`;
- (а позже, в Linux — `epoll`, в BSD — `kqueue` и др., но в экзаменационном билете достаточно понимать `select/poll`).

---

## 3. Системный вызов select(): принцип работы

### 3.1. Общая идея

`select()` позволяет процессу:
- передать ядру **набор дескрипторов** и запрос:
  - «ждать, пока не появятся события чтения/записи/ошибок на этих дескрипторах, или пока не истечёт тайм-аут»;
- ядро:
  - блокирует процесс;
  - отслеживает изменения состояния дескрипторов;
  - как только что-то становится готово — `select()` возвращает, сообщая, какие дескрипторы можно обслуживать.

### 3.2. Прототип select()

(Упрощённо, POSIX-стиль, C):

```c
int select(int nfds,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *exceptfds,
           struct timeval *timeout);
```

Где:
- `nfds` — **наибольший номер дескриптора + 1** (счёт от 0);
- `readfds` — набор дескрипторов, ожидаемых как готовые к чтению;
- `writefds` — набор дескрипторов, ожидаемых как готовые к записи;
- `exceptfds` — набор дескрипторов, для которых нас интересуют исключения (out-of-band данные и т.п.);
- `timeout` — тайм-аут:
  - `NULL` — ждать бесконечно;
  - `{0, 0}` — не ждать (опрос без блокировки);
  - конкретное значение — максимальное время ожидания.

Возвращаемое значение:
- `> 0` — количество дескрипторов, готовых к какому-либо виду операций;
- `0` — истёк тайм-аут, событий нет;
- `< 0` — ошибка.

### 3.3. Наборы дескрипторов и макросы

Тип `fd_set` — битовая маска дескрипторов. Для работы с ней используются макросы:

```c
FD_ZERO(fd_set *set);          // очистить множество
FD_SET(int fd, fd_set *set);   // добавить дескриптор во множество
FD_CLR(int fd, fd_set *set);   // удалить дескриптор
FD_ISSET(int fd, fd_set *set); // проверить, включен ли дескриптор
```

Последовательность действий:

1. Очистить `fd_set`:
   ```c
   FD_ZERO(&readfds);
   ```
2. Добавить нужные дескрипторы:
   ```c
   FD_SET(sockfd, &readfds);
   FD_SET(another_fd, &readfds);
   ```
3. Указать `nfds = max_fd + 1`, где `max_fd` — максимальный дескриптор среди всех множеств.
4. Вызвать `select()`:
   ```c
   int count = select(max_fd + 1, &readfds, &writefds, &exceptfds, &timeout);
   ```
5. После успешного возвращения `select()`:
   - множества **модифицируются ядром**:
     - в них остаются **только те дескрипторы**, которые готовы;
   - проверяем каждый дескриптор:
     ```c
     if (FD_ISSET(sockfd, &readfds)) {
         // можно читать
     }
     ```

Важный момент:
- перед каждым новым вызовом `select()` нужно заново заполнять `fd_set`,
- т.к. после `select()` содержимое множеств изменяется.

### 3.4. Ограничения select()

1. **Максимальное число дескрипторов (FD_SETSIZE)**
   - обычно ограничено (`1024` или другое значение);
   - это **максимальный индекс**, который можно использовать в `fd_set`;
   - масштабируемость ограничена.

2. **Линейный обход**
   - ядру нужно проверять все дескрипторы от 0 до `nfds-1`;
   - сложность `O(N)` — при большом `N` неэффективно.

3. **Неудобство пересоздания fd_set**
   - каждый раз перед `select()` нужно заново заполнять все множества.

Тем не менее:
- `select()` исторически широко используется;
- хорошо подходит для **относительно небольшого** числа соединений.

---

## 4. Системный вызов poll(): мотивация и устройство

### 4.1. Почему появился poll()

Для устранения некоторых ограничений `select()`:
- привязки к `FD_SETSIZE`;
- необходимости использовать битовые маски;
- неудобства с `nfds` и пересозданием множеств;

был разработан **`poll()`**.

### 4.2. Прототип poll()

```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

Где:
- `fds` — указатель на **массив структур `pollfd`**;
- `nfds` — количество элементов в массиве;
- `timeout` — тайм-аут в миллисекундах:
  - `-1` — ждать бесконечно;
  - `0` — не ждать (опрос).

Структура `pollfd`:

```c
struct pollfd {
    int   fd;      // дескриптор
    short events;  // интересующие события (битовая маска)
    short revents; // события, которые реально произошли (заполняется ядром)
};
```

### 4.3. Поля events и revents

Типичные флаги в `events`:

- `POLLIN` — интересует **готовность к чтению**;
- `POLLOUT` — интересует **готовность к записи**;
- `POLLERR` — интересуют **ошибки**;
- `POLLHUP` — «обрыв» (hang up, закрытие соединения);
- `POLLPRI` — приоритетные данные.

Процесс взаимодействия:

1. Заполнить массив `fds`:
   ```c
   struct pollfd fds[2];
   fds[0].fd = sock1;
   fds[0].events = POLLIN;  // ждём данных для чтения
   fds[1].fd = sock2;
   fds[1].events = POLLIN | POLLOUT; // ждём чтение и запись
   ```
2. Вызвать `poll()`:
   ```c
   int count = poll(fds, 2, timeout);
   ```
3. После успешного возвращения:
   - в поле `revents` каждого элемента будут флаги произошедших событий;
   - нужно перебрать массив и анализировать `revents`:
     ```c
     if (fds[0].revents & POLLIN) {
         // можно читать из sock1
     }
     if (fds[1].revents & POLLOUT) {
         // sock2 готов к записи
     }
     ```

Преимущества:

- нет жёсткого ограничения, как `FD_SETSIZE`;
- можно использовать **любой** дескриптор (`fd >= 0`), либо `-1` для пропуска;
- удобнее добавлять/удалять дескрипторы — просто менять массив.

Недостаток:

- всё равно ядру нужно **перебирать весь массив** длиной `nfds`, т.е. сложность `O(N)`.

---

## 5. Сравнение select и poll

| Характеристика                          | select()                                      | poll()                                            |
|----------------------------------------|-----------------------------------------------|---------------------------------------------------|
| Представление дескрипторов             | `fd_set` (битовая маска)                      | массив `struct pollfd`                            |
| Ограничение на число дескрипторов      | есть (`FD_SETSIZE`, обычно 1024)              | нет жёсткого ограничения (ограничено ресурсами)  |
| Источник информации о событиях         | `fd_set` модифицируется ядром                 | поле `revents` в `pollfd`                         |
| Сложность обработки в ядре            | `O(N)` по диапазону [0, nfds)                 | `O(N)` по массиву длины `nfds`                    |
| Удобство добавления/удаления дескрипторов | требуется заново формировать `fd_set`       | достаточно обновить массив                        |
| Тайм-аут                               | `timeval` (сек + мкс)                         | миллисекунды (int)                                |

Оба механизма:
- являются **уровнем мультиплексирования ввода-вывода**;
- позволяют одному потоку/процессу работать сразу с множеством дескрипторов.

---

## 6. Типичная схема использования select/poll в сервере

Для многоклиентского сервера (например, TCP-чат):

1. Создаём слушающий сокет `listen_sock` (`socket + bind + listen`).
2. Добавляем его в набор дескрипторов:
   - для `select()` — в `fd_set readfds`;
   - для `poll()` — в массив `fds` с `events = POLLIN`.
3. Заходим в основной цикл:

   **Пример на select:**
   ```c
   for (;;) {
       fd_set readfds = master_set;     // копируем базовый набор
       int ready = select(max_fd + 1, &readfds, NULL, NULL, NULL);
       if (ready < 0) { /* ошибка */ }

       // проверяем, какие дескрипторы готовы
       if (FD_ISSET(listen_sock, &readfds)) {
           // новое входящее соединение
           int client = accept(listen_sock, ...);
           FD_SET(client, &master_set);
           if (client > max_fd) max_fd = client;
       }

       // проверяем всех клиентов
       for (fd = 0; fd <= max_fd; ++fd) {
           if (fd != listen_sock && FD_ISSET(fd, &readfds)) {
               // пришли данные от клиента fd
               // читаем, обрабатываем, при закрытии — FD_CLR(fd, &master_set)
           }
       }
   }
   ```

   **Пример на poll:**
   ```c
   for (;;) {
       int ready = poll(fds, nfds, -1);
       if (ready < 0) { /* ошибка */ }

       for (i = 0; i < nfds; ++i) {
           if (fds[i].revents & POLLIN) {
               if (fds[i].fd == listen_sock) {
                   // новое соединение
               } else {
                   // данные от клиента
               }
           }
       }
   }
   ```

4. Таким образом:
   - нет необходимости выделять отдельный поток на клиента;
   - можно эффективно обслуживать десятки/сотни соединений в одном потоке (при разумной нагрузке).

---

## 7. Уровень триггеров: уровневый (level-triggered) характер select/poll

По своей природе:

- `select()` и `poll()` — **уровневые (level-triggered)** механизмы:
  - если дескриптор готов (например, в буфере есть данные для чтения),
  - то на каждом вызове `select/poll` он будет считаться «готовым»,
  - пока данные не будут полностью прочитаны.

Это отличается от **edge-triggered** (как в `epoll` с флагом `EPOLLET`), где событие выдаётся при переходе состояния (например, данные появились, но не при каждом вызове, пока они есть).

---

## 8. Проблемы масштабирования и связь с epoll/kqueue (краткое упоминание)

Хотя в билете акцент на `select/poll`, важно понимать:

- при очень большом числе дескрипторов (тысячи и десятки тысяч) `select` и `poll` становятся неэффективными:
  - сложность `O(N)` при каждом вызове;
  - увеличение задержек.

Для решения этих проблем появились:

- Linux: `epoll`;
- BSD-системы: `kqueue`;
- и другие высокопроизводительные интерфейсы.

Но `select` и `poll`:
- остаются базовыми, стандартизированными и широко поддерживаемыми механизмами;
- важны для понимания **общей концепции мультиплексированного ввода-вывода**.

---

## 9. Итоговый конспект (для запоминания)

1. **Мотивация**:
   - Нужно обслуживать множество дескрипторов (сокеты, файлы) одним потоком, не используя тысячи потоков/процессов.
   - Блокирующий I/O на одном дескрипторе нельзя допускать, т.к. «зависнет» вся программа.

2. **select()**:
   - принимает три набора дескрипторов (`readfds`, `writefds`, `exceptfds`) и тайм-аут;
   - блокируется до появления события или истечения тайм-аута;
   - возвращает количество **готовых** дескрипторов;
   - `fd_set` — битовая маска, с которой работают макросы `FD_SET`, `FD_ISSET` и т.д.;
   - имеет ограничения по `FD_SETSIZE` и требует линейного обхода.

3. **poll()**:
   - использует массив структур `pollfd`;
   - в `events` задаются интересующие события (POLLIN, POLLOUT и др.);
   - ядро заполняет поле `revents` с фактическими событиями;
   - нет жёсткого ограничения по номеру дескриптора;
   - также требует линейного обхода по массиву.

4. **Типичное использование**:
   - сервер:
     - слушает сокет (listen);
     - добавляет дескрипторы клиентов в набор/массив;
     - в цикле выполняет `select()`/`poll()`;
     - обрабатывает события только на тех дескрипторах, которые готовы.

5. **Характер событий**:
   - `select`/`poll` — **уровневые** (level-triggered): дескриптор считается готовым, пока состояние (есть данные и т.п.) не изменится.

6. **Роль**:
   - это механизм **мультиплексирования ввода-вывода**;
   - часть интерфейса «сети и I/O в пользовательском пространстве»;
   - позволяет эффективно использовать один поток для обработки множества источников данных.

Этот конспект можно использовать как развёрнутый ответ на экзаменационный билет  
**«select/poll: мотивация и принципы работы»**.