# IPC (Inter-Process Communication): подробное описание механизмов

## 1. Общая идея IPC

IPC — это механизмы, предоставляемые операционной системой для взаимодействия изолированных процессов.
Так как каждый процесс имеет собственное виртуальное адресное пространство, прямой доступ к памяти других процессов запрещён.  
IPC решает эту проблему контролируемым и безопасным образом.

Основные задачи IPC:
- передача данных;
- синхронизация;
- уведомление о событиях;
- организация архитектур «клиент–сервер».

Типичный путь выбора:
- нужно просто склеить stdout одного процесса со stdin другого → pipe/FIFO;
- нужен поток/сообщения между неродственными процессами на одной машине → Unix sockets, POSIX MQ;
- нужно много данных и минимум копирований → shared memory + синхронизация;
- нужен сетевой доступ → INET sockets (TCP/UDP) или RPC поверх них.

---

## 2. Pipes (каналы)

### 2.1 Anonymous pipes

**Неименованные каналы** — самый простой IPC-механизм.

Характеристики:
- однонаправленный поток байтов;
- работают только между родственными процессами (parent–child);
- не имеют имени в файловой системе;
- создаются системным вызовом `pipe()`.

Применение:
- передача данных между процессами в shell (`cmd1 | cmd2`);
- простые цепочки обработки данных.

Ограничения:
- нет структуры сообщений;
- нельзя использовать для произвольных процессов.

Мини-пример (родитель пишет, ребёнок читает):

```c
int fd[2];
pipe(fd);
if (!fork()) {  // child
    close(fd[1]);
    char buf[16]; read(fd[0], buf, sizeof buf);
    _exit(0);
}
close(fd[0]);
write(fd[1], "hi\n", 3);
```

---

### 2.2 Named pipes (FIFO)

**Именованные каналы (FIFO)** расширяют возможности pipes.

Особенности:
- имеют имя в файловой системе;
- могут использоваться неродственными процессами;
- поддерживают однонаправленный поток данных.

Создание:
- `mkfifo` или системный вызов `mkfifo()`.

Использование:
- простые IPC-сценарии между сервисами;
- обмен потоковыми данными.

Мини-пример:

```bash
mkfifo /tmp/f
producer > /tmp/f &
consumer < /tmp/f
```

---

## 3. Очереди сообщений (Message Queues)

### 3.1 Общая идея

Очереди сообщений позволяют передавать **дискретные сообщения**, а не поток байтов.

Сообщение включает:
- тип (или приоритет);
- полезную нагрузку;
- размер.

---

### 3.2 System V Message Queues

Особенности:
- идентифицируются ключом;
- сообщения выбираются по типу;
- ядро управляет очередью.

Плюсы:
- асинхронный обмен;
- адресация сообщений.

Минусы:
- устаревший API;
- сложность очистки ресурсов.

Мини-пример (очередь с ключом):

```c
int q = msgget(0x1234, IPC_CREAT | 0600);
struct { long type; char text[32]; } m = {1, "ping"};
msgsnd(q, &m, strlen(m.text)+1, 0);
msgrcv(q, &m, sizeof m.text, 0, 0); // type==0 => первое сообщение
```

---

### 3.3 POSIX Message Queues

Улучшения:
- именованные очереди;
- файловая семантика;
- лучшая переносимость.

Использование:
- серверные приложения;
- системы управления задачами.

Мини-пример:

```c
#include <mqueue.h>

mqd_t mq = mq_open("/myq", O_CREAT|O_RDWR, 0600, NULL);
mq_send(mq, "hello", 5, 10);      // prio=10
char buf[16]; unsigned prio;
ssize_t n = mq_receive(mq, buf, sizeof buf, &prio);
```

---

## 4. Shared Memory (разделяемая память)

### 4.1 Принцип работы

Разделяемая память позволяет нескольким процессам:
- отобразить один и тот же участок физической памяти;
- работать с данными напрямую, без копирования.

Создаётся через:
- System V (`shmget`);
- POSIX (`shm_open`).

Мини-пример (POSIX shm + mmap):

```c
int fd = shm_open("/seg", O_CREAT|O_RDWR, 0600);
ftruncate(fd, 4096);
void *p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
```

---

### 4.2 Производительность

Преимущества:
- максимальная скорость IPC;
- отсутствие копирования данных.

Недостатки:
- сложность синхронизации;
- риск гонок данных.

---

### 4.3 Синхронизация

Для корректной работы используются:
- семафоры;
- мьютексы;
- атомарные операции.

Частый паттерн: данные в shared memory, синхронизация — через POSIX семафоры/мьютексы, размещённые там же. Это даёт обмен без копирований, но требует аккуратности (инициализация, обработка падений процесса).

---

## 5. Семафоры

### 5.1 Назначение

Семафоры предназначены для **синхронизации**, а не передачи данных.

Работают как счётчик:
- `P()` — уменьшение (ожидание);
- `V()` — увеличение (сигнал).

---

### 5.2 Виды семафоров

- бинарные (0 или 1);
- счётные (N ресурсов).

Используются для:
- ограничения доступа;
- упорядочивания выполнения процессов.

### 5.3 Мини-пример (POSIX семафор)

```c
#include <semaphore.h>

sem_t sem;
sem_init(&sem, 0, 1);      // 0 — внутрипроцессный, стартовое значение 1

// Поток 1
sem_wait(&sem);
/* критическая секция */
sem_post(&sem);

// Поток 2
sem_wait(&sem);
/* критическая секция */
sem_post(&sem);
```

Для межпроцессного варианта разместите семафор в разделяемой памяти (`shm_open` + `mmap`) или используйте именованный семафор (`sem_open("/name", ...)`).

---

## 6. Мьютексы

**Мьютекс** — механизм взаимного исключения.

Особенности:
- только один владелец;
- блокирует остальных.

Используется:
- чаще между потоками;
- возможен межпроцессный вариант (POSIX mutex + shared memory).

### 6.1 Мини-пример (pthread mutex)

```c
#include <pthread.h>

static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

void *worker(void *arg) {
    pthread_mutex_lock(&mtx);
    /* критическая секция */
    pthread_mutex_unlock(&mtx);
    return NULL;
}
```

Для межпроцессного использования задают атрибут `pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED)` и размещают мьютекс в разделяемой памяти.

---

## 7. Сигналы

### 7.1 Суть сигналов

**Сигналы** — асинхронные уведомления процессу.

Примеры:
- `SIGTERM`, `SIGKILL`;
- `SIGINT`;
- `SIGSEGV`.

---

### 7.2 Особенности

- не предназначены для передачи данных;
- используются для управления и уведомлений;
- могут прерывать выполнение процесса.

---

## 8. Сокеты

### 8.1 Общая концепция

**Сокеты** — самый универсальный IPC-механизм.

Позволяют:
- локальное взаимодействие;
- сетевое взаимодействие.

---

### 8.2 UNIX Domain Sockets

Особенности:
- работают только внутри одной ОС;
- высокая производительность;
- файловая адресация.

Используются:
- systemd;
- X11;
- DBus.

Мини-пример (stream):

```c
int s = socket(AF_UNIX, SOCK_STREAM, 0);
struct sockaddr_un addr = { .sun_family = AF_UNIX };
strcpy(addr.sun_path, "/tmp/sock");
bind(s, (struct sockaddr*)&addr, sizeof addr);
listen(s, 8);
int c = accept(s, NULL, NULL);
```

---

### 8.3 Internet Sockets (TCP/UDP)

Используются для:
- сетевых сервисов;
- распределённых систем.

Поддерживают:
- надёжную (TCP);
- ненадёжную (UDP) передачу данных.

Мини-пример (UDP):

```c
int s = socket(AF_INET, SOCK_DGRAM, 0);
struct sockaddr_in sa = {.sin_family=AF_INET,.sin_port=htons(9999),
                         .sin_addr.s_addr=htonl(INADDR_LOOPBACK)};
sendto(s, "ping", 4, 0, (void*)&sa, sizeof sa);
```

---

## 9. System V IPC vs POSIX IPC

| Критерий | System V | POSIX |
|--------|---------|-------|
| Современность | Устаревший | Современный |
| Именование | Ключи | Имена |
| Очистка | Сложная | Простая |
| Переносимость | Ограниченная | Высокая |

---

## 10. Выбор IPC-механизма

Выбор зависит от:
- скорости;
- объёма данных;
- сложности реализации;
- локального или сетевого характера взаимодействия;
- требований к синхронизации.

Быстрая шпаргалка:
- **pipe/FIFO** — просто передать поток байтов, без структуры и без неродственных процессов (FIFO — можно неродственным).
- **POSIX MQ** — короткие сообщения с приоритетом, удобный API, внутри одной машины.
- **shared memory + sync** — максимум скорости и минимум копирований; нужна дисциплина синхронизации.
- **Unix sockets** — удобные двусторонние каналы между процессами на одной машине, поддержка SOCK\_STREAM/SOCK\_DGRAM/SEQPACKET.
- **INET sockets** — когда нужен сетевой стек, TCP для надёжности, UDP для минимальной задержки/оверхеда.

---

## 11. Итог

IPC предоставляет:
- разные уровни абстракции;
- баланс между скоростью и удобством;
- фундамент для построения многопроцессных систем.

Грамотный выбор IPC — ключ к корректной и производительной архитектуре ОС и приложений.
