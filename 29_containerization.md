
Автор билета - @branch_study
# 1. Определение контейнеризации

Контейнеризация - это технология, которая позволяет запускать приложения в изолированной среде, обеспечивая:
	•	независимость от операционной системы хоста;
	•	изоляцию процессов, файловой системы, сетевых ресурсов и т.д.;
	•	возможность быстрой упаковки, переноса и масштабирования приложений.
Контейнер - это легковесная «мини-операционная система», которая использует ядро хоста, но имеет своё пространство пользователя, файловую систему и окружение.

Но мало, кто знает, что контейнеризация - это не магия, а просто объеденинение некоторых механизмов Linux для того чтобы изолированно запускать процессы, то что здесь рассказано, возможно не было на парах, но крайне полезно (у меня на собесах спрашивали)

## 0. Контекст: виртуализация и её уровни (по заметкам)

Контейнеры появились на фоне разных подходов к виртуализации. Снизу вверх можно выстроить цепочку:
- RTL-симуляторы и эмуляторы (Verilator), затем симуляция узлов CPU (gem5, bochs);
- полноценных виртуальных машин на гипервизоре (KVM, VMware/Hyper-V);
- контейнеры как самая лёгкая ступень.

Классические подходы к виртуализации:
- **Full virtualization** — гостевая ОС видит «полное» виртуальное железо, все привилегированные инструкции перехватываются гипервизором.
- **Paravirtualization** — гостевая ОС знает, что работает в гостях, и использует упрощённые интерфейсы вместо эмуляции реального железа (экономия накладных расходов).
- **Hardware-assisted virtualization** — расширения CPU (VT-x, AMD-V/SVM) вводят отдельные привилегированные уровни для хоста и гостя, ускоряя переключения и обработку ловушек.

Контейнеры не эмулируют железо и не требуют отдельного гипервизора: они переиспользуют ядро хоста и изолируют процессы через механизмы, описанные ниже.

## Механизмы ядра для формирования и управления контейнером

Контейнер в Linux - это не отдельная сущность ядра, а комбинация нескольких механизмов: **изоляция ресурсов** и **ограничение их потребления**. За это отвечают два больших блока:
1. **Namespaces** - создают "области видимости", т.е. то, какие объекты системы процесс может видеть.
2. **Cgroups (control groups)** - управляют "областью потребления ресурсов", т.е. сколько ресурсов процесс может использовать.
Дополнительно используются вспомогательные механизмы: chroot, дисковые квоты, изоляция devpts.
### 1. chroot
- Самый простой и старый механизм: процессу подсовывается новая "корневая директория" (/).
- Смысл: процесс "думает", что / - это вся файловая система, хотя на самом деле это только поддерево.
- Ограничения: легко обойти (можно выйти из chroot при наличии прав root), поэтому в контейнерах используется в комбинации с namespaces.
### 2. Control Groups (cgroups)

Cgroups позволяют объединить процессы в группы и ограничить/учитывать использование ими ресурсов.
**Основные контроллеры и их назначение:**
- memory - ограничивает потребление оперативной памяти, задаёт лимиты, можно отлавливать OOM (Out Of Memory).
- cpu - распределение CPU-времени между группами процессов, можно задавать приоритеты.
- blkio - ограничивает скорость ввода-вывода к блочным устройствам (например, чтобы контейнер не "забил" диск).
- devices - ограничивает доступ к определённым устройствам /dev, например запрет на прямую работу с диском.
- freezer - можно "заморозить" группу процессов (приостановить выполнение). Используется для checkpoint/restore или "пауз" контейнера.
- pids - ограничивает количество процессов/потоков, создаваемых внутри группы.
- net_cls, net_prio - управление сетевым трафиком (маркировка пакетов, приоритеты).
**Зачем нужны cgroups?**  
Чтобы контейнеры на одном хосте не "съедали" ресурсы друг у друга
### 3. Namespaces
Namespaces позволяют "разделить" объекты ядра так, что процессы в одном контейнере не видят объекты из другого.
**Виды namespaces:**
- pid - изоляция процессов. Процесс внутри контейнера видит только свои PID, root-контейнер может видеть всё. Можно сделать свой "init".
- net - отдельный сетевой стек: свои интерфейсы, маршруты, iptables, сокеты. Позволяет контейнеру иметь виртуальный сетевой интерфейс.
- mount - своя таблица монтирования файловых систем. Контейнер видит только свои точки монтирования, можно "подсовывать" ему отдельные директории.
- uts - имя хоста (hostname) и доменное имя. Позволяет каждому контейнеру иметь своё имя.
- ipc - изоляция межпроцессного взаимодействия: очереди сообщений, разделяемая память, семафоры.
- user - раздельные идентификаторы пользователей. UID 0 внутри контейнера может соответствовать непривилегированному UID снаружи. Это основа "rootless containers".
- time - разные контейнеры могут иметь разное представление времени (например, смещение часов).
- cgroup (относительно новый) - видимость только "своего" дерева cgroups.

**Зачем нужны namespaces?**  
Чтобы процессы "думали", что они работают на отдельной системе, хотя на самом деле они запущены на общем ядре.
### 4. Дисковая квота
Используется для ограничения размера доступного пространства. Можно задавать лимиты на уровне файловой системы (например, ext4 или XFS поддерживают квоты). В контейнерах применяется для предотвращения "забивания" диска.
### 5. Изоляция devpts
Для эстетов и любителей тонкой настройки: отдельный экземпляр devpts (псевдотерминалы). Это нужно, чтобы у каждого контейнера был свой /dev/pts, и не пересекались терминалы разных контейнеров.
## Итог
- **Namespaces** отвечают за то, **что процесс видит** (видимость объектов ядра).
- **Cgroups** отвечают за то, **сколько ресурсов он может использовать**.
- **chroot, дисковые квоты, devpts** - вспомогательные механизмы.

Итак, когда мы немного разобрались с внутрянкой, можно переходить к практическим аспектам. Важно понять, чем контейнер отличается от виртуалки: 

| Характеристика     | Виртуальная машина (VM)      | Контейнер                        |
| ------------------ | ---------------------------- | -------------------------------- |
| Изоляция           | Полная, через гипервизор     | Частичная, через ядро ОС         |
| Размер             | Большой (гигабайты)          | Лёгкий (мегабайты — сотни МБ)    |
| Загрузка           | Медленная                    | Быстрая                          |
| Производительность | Ниже (требуется эмуляция ОС) | Выше (работает через ядро хоста) |
| Аппаратные ресурсы | Выделяются отдельные         | Общие с хостом                   |
> Контейнер использует ресурсы хоста напрямую, без полного эмулятора ОС.

### **. Основные преимущества контейнеризации**

- Лёгкая изоляция и безопасность процессов.
- Портативность - контейнер можно запустить на любой системе с Docker/Podman.
- Быстрая доставка (CI/CD, DevOps).
- Масштабируемость (много контейнеров на одном хосте).
### **Основные недостатки и ограничения**

- Контейнеры используют ядро хоста, поэтому уязвимости ядра могут быть критичны.
- Меньшая изоляция по сравнению с VM.
- Ограничение по доступу к аппаратуре (например, GPU требует специальных драйверов).

### **6. Примеры инструментов контейнеризации**

# **Docker**
### **1. Что это такое**
Docker — это инструмент для создания, распространения и запуска контейнеров.
- Контейнер — это упакованное приложение с его зависимостями, библиотеками и файловой системой.
- Docker позволяет запускать одно и то же приложение **везде одинаково**, независимо от ОС хоста (главное, чтобы был Linux/Windows с поддержкой контейнеров).
### **2. Основные компоненты**
- **Docker Engine** — ядро Docker, которое запускает контейнеры.
- **Docker CLI** — командная строка для работы с образами и контейнерами (docker build, docker run).
- **Docker Hub** — облачный репозиторий образов, где можно брать готовые контейнеры (например, Nginx, Python).
### **3. Как работает**
1. Ты создаёшь **Dockerfile** — инструкцию, как собрать образ.
2. Docker собирает **образ** (docker build).
3. Из образа создаётся **контейнер** (docker run).
4. Контейнер работает в **изолированной среде** через namespaces и cgroups ядра Linux.
### **4. Плюсы Docker**
- Легковесные контейнеры, быстрый запуск.
- Портативность приложений.
- Огромная экосистема: образы, плагины, Docker Compose для оркестрации.
### **5. Минусы Docker**
- Использует **демон** (dockerd) с правами root — потенциальная угроза безопасности.
- Иногда сложнее интегрировать в существующие системные сервисы.
# **Podman**
### **1. Что это такое**
Podman — альтернатива Docker, совместимая с CLI Docker, но с ключевым отличием: **не требует демона**.
- Контейнеры запускаются напрямую, часто без root.
- Подходит для более безопасной работы в продакшн-средах.
### **2. Основные особенности**
- **Без демона**: нет постоянного процесса с привилегиями root.
- **Rootless контейнеры**: можно запускать контейнеры от обычного пользователя.
- **Совместимость с Docker**: большинство команд идентичны (podman run, podman build).
- **Поды**: как в Kubernetes — несколько контейнеров могут запускаться вместе, деля сеть и тома.
### **3. Плюсы Podman**
- Более безопасно (rootless).
- Легко интегрировать в CI/CD пайплайны.
- Поддержка Kubernetes YAML прямо (podman generate kube).
### **4. Минусы Podman**
- Меньше готовых инструментов и экосистемы, чем у Docker.
- На Windows/macOS иногда требуется WSL или VM.
