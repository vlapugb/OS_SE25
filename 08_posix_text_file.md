# Экзаменационный билет: POSIX — понятия на примере текстового файла

## 1. Что такое POSIX

**POSIX (Portable Operating System Interface)** — это семейство стандартов, определяющих:
- интерфейс между **приложением** и **операционной системой**;
- поведение системных вызовов (API), оболочки (shell) и утилит.

Главная цель POSIX:
- обеспечить **переносимость программ** между различными Unix‑подобными системами (Linux, BSD, macOS и др.);
- задать единые правила работы с процессами, файлами, правами доступа и т.п.

Важно: POSIX — это **не сама ОС**, а **набор требований и спецификаций**, как ОС должна себя вести и какие интерфейсы предоставлять.

В этом билете рассматриваем POSIX‑понятия на **конкретном примере: обычный текстовый файл** в файловой системе.

---

## 2. Файл в POSIX: обобщённое понятие

В POSIX почти всё трактуется как **файл**:
- обычные файлы (например, `text.txt`);
- каталоги;
- устройства (`/dev/sda`, `/dev/tty`);
- каналы (pipe), сокеты и т.п.

**Обычный текстовый файл** — это файл, в котором хранятся байты данных, обычно интерпретируемые как символы текста (UTF‑8, ASCII и др.).

### Главное разделение понятий

В POSIX важно различать:
1. **Имя файла (путь)** — строка, например:  
   - `text.txt`  
   - `./docs/text.txt`  
   - `/home/user/text.txt`
2. **Сам объект файла** — структура данных в файловой системе (inode), содержащая:
   - указатели на блоки данных на диске;
   - метаданные (владелец, права, время создания, размер и т.д.).

**Вывод:** имя — это только **ссылка** на файл (каталожная запись), а реальный файл — это **объект в файловой системе**.

---

## 3. Путь (path) и каталоги

### 3.1. Типы путей

- **Абсолютный путь** начинается с корня `/`  
  Пример: `/home/user/documents/text.txt`
- **Относительный путь** задаётся относительно текущего каталога процесса  
  Пример: `./text.txt`, `../docs/text.txt`

POSIX определяет:
- специальный каталог `.` — текущий;
- `..` — родительский.

### 3.2. Каталог как файл

Каталог в POSIX — это **особый тип файла**, который содержит:
- список записей: имя → номер inode объекта (файла/каталога).

Например, в каталоге `/home/user` может быть запись:
- `text.txt → inode #12345`

---

## 4. Inode: внутренняя сущность файла

**Inode** (индексный дескриптор) — структура, описывающая файл **без привязки к имени**.

В inode хранится:
- тип объекта (обычный файл, каталог, символьное/жёсткое устройство и т.д.);
- владелец (UID), группа (GID);
- права доступа;
- размер файла (в байтах);
- времена: доступа (atime), изменения содержимого (mtime), изменения метаданных (ctime);
- ссылки на блоки данных на диске;
- количество жёстких ссылок (hard links) на этот файл.

**Важно:** один и тот же inode может иметь **несколько имён** (жёсткие ссылки).

---

## 5. Файловые дескрипторы (file descriptor)

Когда процесс хочет работать с текстовым файлом, он:
1. Указывает **имя файла** (путь).
2. ОС находит соответствующий **inode**.
3. ОС создаёт в таблице открытых файлов процесса запись и возвращает **целое число** — **файловый дескриптор** (FD).

Файловый дескриптор — это **малое целое число**, идентификатор открытого файла внутри процесса.

Стандартные дескрипторы:
- `0` — стандартный ввод (stdin);
- `1` — стандартный вывод (stdout);
- `2` — стандартный поток ошибок (stderr).

При открытии текстового файла, например `text.txt`, программа может получить дескриптор `3`, `4` и т.д.

---

## 6. Основные системные вызовы POSIX для работы с текстовым файлом

Рассмотрим классический набор вызовов POSIX на примере файла `text.txt`.

### 6.1. open()

```c
int fd = open("text.txt", O_RDONLY);
```

- Открывает файл по имени.
- Возвращает **файловый дескриптор** (fd) или `-1` при ошибке.
- Флаги:
  - `O_RDONLY` — только чтение;
  - `O_WRONLY` — только запись;
  - `O_RDWR` — чтение и запись;
  - `O_CREAT` — создать файл, если не существует (вместе с правами доступа);
  - `O_TRUNC` — обнулить файл при открытии на запись и др.

При успешном `open()` для `text.txt`:
- ОС создаёт запись в таблице открытых файлов процесса:
  - указывает inode файла;
  - устанавливает **текущую позицию** (смещение) в 0;
  - хранит режим доступа (чтение/запись).

### 6.2. read()

```c
ssize_t n = read(fd, buffer, size);
```

- Читает до `size` байт из файла, связанного с дескриптором `fd`, в `buffer`.
- Возвращает количество реально прочитанных байт или `0` при достижении конца файла.

Особенности:
- Чтение происходит **по текущей позиции (offset)**.
- После чтения offset **сдвигается** на количество прочитанных байт.
- Например, для текстового файла: читаем строку, потом следующую и т.д.

### 6.3. write()

```c
ssize_t n = write(fd, buffer, size);
```

- Записывает `size` байт из `buffer` в файл, связанный с `fd`.
- Возвращает количество реально записанных байт.
- Так же изменяет **позицию** в файле.

Если открыть `text.txt` с `O_WRONLY` и вызвать `write()`, новые данные попадут в файл (в зависимости от режима — поверх существующих или в конец).

### 6.4. lseek()

```c
off_t pos = lseek(fd, offset, whence);
```

- Изменяет **текущее смещение** (позицию) в файле.
- `whence`:
  - `SEEK_SET` — от начала файла;
  - `SEEK_CUR` — от текущей позиции;
  - `SEEK_END` — от конца файла.

Например, можно:
- перескочить к середине текстового файла;
- установить позицию в конец и дозаписать данные.

### 6.5. close()

```c
close(fd);
```

- Закрывает файл:
  - дескриптор становится недействительным;
  - запись в таблице открытых файлов процесса удаляется;
  - если больше нет процессов, использующих этот файл, ОС может освободить ресурсы.

---

## 7. Права доступа к файлу (разрешения)

POSIX определяет модель прав доступа:
- у каждого файла есть:
  - **владелец** (user, UID);
  - **группа** (group, GID);
  - права для:
    - пользователя (u),
    - группы (g),
    - остальных (o).

Права:
- `r` — read (чтение);
- `w` — write (запись);
- `x` — execute (исполнение).

Для текстового файла `text.txt` обычно:
- `-rw-r--r--`
  - владелец может читать и писать;
  - группа и остальные — только читать.

При вызове `open()` ОС проверяет:
- кто является владельцем процесса (UID, GID);
- какие права есть у файла;
- можно ли открыть на чтение/запись.

---

## 8. Метаданные файла: stat()

Системный вызов:

```c
struct stat st;
int res = stat("text.txt", &st);
```

Позволяет получить:
- режим (тип файла и права);
- размер (st_size) — количество байт в файле;
- UID, GID;
- количество жёстких ссылок;
- времена atime, mtime, ctime.

Для текстового файла `text.txt` это:
- размер в байтах (например, 1024);
- тип: обычный файл;
- права: `rw-r--r--` и т.д.

---

## 9. Связь между процессом и файлом

В POSIX есть несколько уровней:

1. **Имя файла** в каталоге → inode файла.
2. **Inode файла** → объект в файловой системе (данные + метаданные).
3. **Таблица открытых файлов ядра**:
   - хранит для каждого открытого файла:
     - указатель на inode;
     - текущую позицию (offset);
     - режим (чтение/запись);
     - флаги.
4. **Таблица дескрипторов процесса**:
   - сопоставляет **целые числа** (0, 1, 2, 3, …) с записями в таблице открытых файлов.

Когда процесс читает `text.txt`:
- он использует **номер дескриптора** (например, 3);
- ядро по дескриптору находит запись в таблице открытых файлов;
- получает inode и позицию;
- читает нужные данные.

---

## 10. Потоки, буферизация и «текстовый» характер файла

На уровне POSIX текстовый файл — это просто **последовательность байтов**.  
Понятие «строка» (заканчивающаяся `\n`) — это **условность на уровне библиотеки** (например, `stdio` в C).

Часто поверх системных вызовов POSIX используются буферизованные потоки:
- `fopen()`, `fread()`, `fgets()`, `fprintf()` и др.
- Они внутренне используют `open()`, `read()`, `write()`, `close()`, но:
  - добавляют буферы;
  - работают с понятием строк;
  - могут по-разному трактовать конец строки (особенно в разных ОС).

---

## 11. Удаление файла: unlink()

```c
unlink("text.txt");
```

В POSIX `unlink()`:
- удаляет **имя** из каталога;
- уменьшает счётчик жёстких ссылок inode;
- если счётчик стал 0 **и** нет открытых дескрипторов на этот файл:
  - данные и inode могут быть реально освобождены.

Особенность:
- если процесс всё ещё держит открытый файл `text.txt` (есть дескриптор), он может продолжать читать/писать, даже если имя в каталоге уже удалено.

---

## 12. Жёсткие и символьные ссылки

POSIX позволяет иметь несколько имён для одного файла.

### 12.1. Жёсткая ссылка (hard link)

```bash
ln text.txt copy.txt
```

- `text.txt` и `copy.txt` → это **два имени одного и того же inode**.
- У текстового файла будет увеличен счётчик ссылок.
- При изменении файла через одно имя, изменения видны через другое.

### 12.2. Символьная (symbolic) ссылка

```bash
ln -s text.txt link.txt
```

- `link.txt` содержит **путь** к другому файлу.
- Это отдельный файл особого типа (symlink).
- Если удалить `text.txt`, символическая ссылка может стать «сломленной».

---

## 13. Ошибки и errno

При работе с системными вызовами POSIX (open, read, write и др.) возможны ошибки:
- возвращаемое значение обычно `-1`;
- глобальная переменная `errno` хранит код ошибки.

Типичные ошибки при работе с текстовым файлом:
- `ENOENT` — файл не существует (`open("text.txt", ...)`);
- `EACCES` — нет прав доступа;
- `EBADF` — неверный дескриптор файла (например, `read()` после `close()`).

---

## 14. Краткий итог (конспект для запоминания)

1. **POSIX** — стандарт интерфейса ОС, определяет системные вызовы и поведение работы с файлами, процессами и т.д.
2. **Файл в POSIX**:
   - разделяются имя (путь) и объект (inode);
   - текстовый файл — последовательность байтов, обычно интерпретируемых как символы.
3. **Каталог** — особый файл, содержащий соответствие «имя → inode».
4. **Inode** хранит:
   - тип файла, права, владельца;
   - размеры, времена;
   - ссылки на блоки данных;
   - количество жёстких ссылок.
5. **Файловый дескриптор** — целое число, идентификатор открытого файла внутри процесса.
6. Основные системные вызовы POSIX для работы с текстовым файлом:
   - `open()` — открыть файл (получить дескриптор);
   - `read()` — читать данные;
   - `write()` — записывать данные;
   - `lseek()` — менять позицию в файле;
   - `close()` — закрыть файл;
   - `stat()` — получить метаданные;
   - `unlink()` — удалить имя файла.
7. **Права доступа**: три набора (user, group, others) и три бита (r, w, x).
8. Связь между процессом и файлом реализована через:
   - таблицу дескрипторов процесса и таблицу открытых файлов в ядре.
9. Удаление файла в POSIX:
   - сначала удаляется имя (unlink);
   - данные удаляются только когда нет имён и открытых дескрипторов.
10. Жёсткие и символьные ссылки позволяют иметь несколько имён для файла или ссылаться по пути.

Этот конспект можно использовать как готовый ответ на экзаменационный билет по теме  
**«POSIX: понятия на примере текстового файла»**.
