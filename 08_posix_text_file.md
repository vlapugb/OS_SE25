# POSIX — понятия на примере текстового файла. Понятие файлового дескриптора

## 1. Что такое файл в POSIX (на примере текстового файла)

В POSIX/Unix **файл** — это абстракция для работы с данными. Рассмотрим обычный текстовый файл, например:

```text
/home/user/docs/note.txt
```

Для ядра и POSIX этот объект характеризуется:

- **именем и путём** — `note.txt` в каталоге `/home/user/docs`;
- **типом** — обычный файл (regular file);
- **метаданными**:
  - размер в байтах (например, 1234 байта);
  - права доступа (например, `rw-r--r--` → 0644);
  - владелец (uid) и группа (gid);
  - временные метки (время создания/изменения/доступа);
- **содержимым** — последовательность байт (записанный текст).

В файловой системе Unix информация о файле хранится:

- в **каталоге** — соответствие «имя → номер inode»;
- в самом **inode** — метаданные + указатели на блоки данных;
- в **блоках данных** — собственно байты текста.

Важно: для ядра нет понятия «строки текста», есть только **последовательность байт**.

---

## 2. Путь к текстовому файлу и имена

Путь `"/home/user/docs/note.txt"`:

- `/` — корневая директория;
- `home`, `user`, `docs` — подкаталоги;
- `note.txt` — имя файла в каталоге `docs`.

Каталог в Unix — это **особый файл**, содержащий пары вида:

```text
(имя, номер inode)
```

Поэтому:

- **удаление файла** = удаление записи `(имя, inode)` из каталога;
- один inode может иметь несколько имён (жёсткие ссылки).

---

## 3. Открытие текстового файла: жизненный цикл с точки зрения POSIX

Пусть программа хочет прочитать текстовый файл `note.txt`. Примерный сценарий:

```c
int fd = open("/home/user/docs/note.txt", O_RDONLY);
char buf[256];
ssize_t n = read(fd, buf, sizeof(buf));
close(fd);
```

Последовательность действий:

1. **Системный вызов `open()`**:
   - ядро по пути находит нужный каталог и запись `(note.txt, inode)`;
   - проверяет права доступа (можно ли читать?);
   - создаёт запись в системной таблице открытых файлов:
     - указатель на inode файла;
     - текущую позицию чтения/записи `offset` (по умолчанию 0);
     - режим доступа (только чтение, только запись, чтение/запись);
     - флаги (append, non-blocking и т.п.);
   - добавляет запись в таблицу дескрипторов **процесса** и выдаёт **файловый дескриптор** — например, `3`.

2. **Системный вызов `read()`**:
   - по дескриптору `fd` ядро находит запись в таблице открытых файлов;
   - смотрит на текущую позицию `offset` (например, 0);
   - читает данные из соответствующих блоков данных в буфер `buf`;
   - увеличивает `offset` на количество прочитанных байт (например, было 0, стало 256).

3. **Повторные вызовы `read()`**:
   - продолжают чтение с новой позиции `offset` (как «курсор» в файле);
   - когда достигнут конец файла:
     - `read()` возвращает 0 → признак EOF.

4. **Системный вызов `close()`**:
   - запись в таблице дескрипторов процесса освобождается;
   - счётчик ссылок в системной записи открытого файла уменьшается;
   - если больше нет дескрипторов, связанных с этим открытым файлом — ядро может освободить структуру.

---

## 4. Понятие файлового дескриптора (на примере текстового файла)

**Файловый дескриптор (file descriptor, FD)** — это:

- целое число (тип `int` в C), которое процесс использует как «идентификатор» открытого файла;
- индекс в таблице открытых файлов текущего процесса.

Пример:

```c
int fd = open("note.txt", O_RDONLY);
// fd может быть 3, 4, 5 и т.д.
```

Характеристики:

- дескриптор **не хранит** сам файл, а указывает на **структуру в ядре**, связанную с конкретным открытием файла;
- у процесса есть ограниченное количество дескрипторов (системный лимит);
- дескриптор имеет локальный смысл: значение `3` в одном процессе и в другом — разные открытые файлы.

Важное соглашение:

- `0` — стандартный ввод (stdin), например клавиатура или входной поток;
- `1` — стандартный вывод (stdout), например терминал или перенаправлённый файл;
- `2` — поток ошибок (stderr).

Если ваш процесс уже использует 0, 1, 2, то первый открытый через `open()` файл обычно получает номер `3`.

---

## 5. Пример: запись текста в файл через низкоуровневый POSIX API

Создадим текстовый файл и запишем туда строку:

```c
#include <fcntl.h>
#include <unistd.h>

int main(void) {
    int fd = open("log.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        // обработка ошибки
        return 1;
    }

    const char *msg = "Hello, POSIX file!
";
    write(fd, msg, 19);  // 19 байт (включая 
)

    close(fd);
    return 0;
}
```

Разберём по шагам:

1. `open("log.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);`
   - если `log.txt` не существует — создаётся новый текстовый файл;
   - если существует — обрезается до длины 0;
   - права доступа: `rw-r--r--` (владелец может читать и писать, остальные — только читать);
   - возвращаемый дескриптор, например `3`.

2. `write(fd, msg, 19);`
   - записывает 19 байт из памяти в файл;
   - ядро помещает данные в буферы, помечает блоки как «грязные» (будут позже сброшены на диск);
   - позиция в файле `offset` перемещается с 0 на 19.

3. `close(fd);`
   - завершает работу с этим открытием файла со стороны процесса;
   - при необходимости ядро синхронизирует данные с диском.

---

## 6. Операции позиционирования: `lseek()` на текстовом файле

**Текстовый файл** поддерживает произвольный доступ (random access): можно перемещать «курсор» (offset), чтобы читать или записывать не только последовательно.

Пример:

```c
int fd = open("note.txt", O_RDONLY);
char c;

// перепрыгнуть первые 10 байт
lseek(fd, 10, SEEK_SET);

// прочитать 1 байт, начиная с позиции 10
read(fd, &c, 1);

close(fd);
```

`lseek(fd, 10, SEEK_SET);`:

- устанавливает текущую позицию в файле = 10 байт от начала;
- следующий `read` начнётся с 11-го байта файла.

С помощью `lseek(fd, 0, SEEK_END)` можно узнать длину текстового файла:

```c
off_t size = lseek(fd, 0, SEEK_END);
```

---

## 7. Буферизация и строки в текстовом файле

Хотя **ядро** работает только с байтами, на уровне стандартной библиотеки C (`stdio`) мы часто используем работу **со строками**:

```c
FILE *f = fopen("note.txt", "r");
char line[256];

fgets(line, sizeof(line), f);  // читаем строку
fclose(f);
```

Здесь:

- `fopen` и `fgets` — функции библиотеки, которые внутри себя используют системные вызовы `open` и `read`;
- библиотека поддерживает **буферизацию**:
  - читает сразу блоки данных (например, 4 КБ) и выдаёт их по строкам;
  - нам удобнее работать со строками, но на низком уровне всё равно идут операции `read(fd, ...)`.

То есть:

- с точки зрения POSIX и ядра: текстовый файл — просто набор байт;
- «строки» — это удобная логическая абстракция на уровне пользовательского кода.

---

## 8. Наследование файловых дескрипторов при `fork()` (на примере лог-файла)

Пусть есть процесс, который пишет лог в `log.txt`:

```c
int fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
pid_t pid = fork();

if (pid == 0) {
    // дочерний процесс
    write(fd, "child
", 6);
} else {
    // родительский процесс
    write(fd, "parent
", 7);
}
```

Что происходит:

- `open` возвращает один дескриптор `fd`, скажем, 3;
- при `fork()`:
  - у родителя и у ребёнка есть дескриптор `3`;
  - оба указывают на одну и ту же запись в системной таблице открытых файлов;
- флаг `O_APPEND` гарантирует, что каждая запись добавляется в конец файла;
- в итоге в текстовом файле `log.txt` окажутся строки от обоих процессов.

Это классический пример совместного использования **одного текстового файла** разными процессами через один и тот же файловый дескриптор.

---

## 9. Стандартные дескрипторы на примере ввода/вывода текста

Любая консольная программа по умолчанию имеет открытыми:

- `0` — stdin (обычно клавиатура);
- `1` — stdout (экран или перенаправлённый файл);
- `2` — stderr (обычно экран).

Примеры:

```c
char buf[100];
ssize_t n = read(0, buf, sizeof(buf));   // читаем текст с клавиатуры
write(1, buf, n);                        // выводим обратно
```

Если в shell сделать:

```sh
./a.out >output.txt
```

то:

- дескриптор `1` (stdout) будет перенаправлён в **текстовый файл** `output.txt`;
- программа продолжит использовать `write(1, ...)`, но теперь байты попадут в файл, а не на экран.

---

## 10. Ошибки при работе с текстовым файлом и дескрипторами

Типичные проблемы:

- **Файл не найден**:

  ```c
  int fd = open("note.txt", O_RDONLY);
  if (fd == -1 && errno == ENOENT) {
      // файла нет
  }
  ```

- **Нет прав** (например, чтение чужого файла):

  `errno == EACCES`.

- **Превышен лимит дескрипторов**:

  - `EMFILE` — слишком много открытых файлов в процессе;
  - `ENFILE` — превышен общий системный лимит.

- **Неверный дескриптор**:

  - вызов `read(fd, ...)` после `close(fd)` → ошибка `EBADF`.

Поэтому:

- всегда проверяют **результаты** `open`, `read`, `write`, `close` и анализируют `errno`.

---

## 11. Краткое резюме

1. В POSIX текстовый файл — это просто **последовательность байт** с метаданными (права, владелец, размер, времена).
2. Каталоги хранят соответствие «имя → inode», inode — метаданные + указатели на данные.
3. **Файловый дескриптор** — целое число, индекс в таблице открытых файлов процесса:
   - процесс использует его для обращения к открытому текстовому файлу (и другим объектам);
   - у разных процессов значения дескрипторов не связаны между собой.
4. Основной жизненный цикл работы с текстовым файлом:
   - `open` → получить дескриптор;
   - `read`/`write` → читать/записывать байты;
   - `lseek` → перемещать позицию чтения/записи;
   - `close` → освободить дескриптор.
5. Дескрипторы наследуются при `fork()` и могут использоваться несколькими процессами одновременно (пример: общий логовый текстовый файл).
6. Стандартные дескрипторы 0/1/2 позволяют легко перенаправлять текстовый ввод-вывод между терминалом и файлами средствами shell.
