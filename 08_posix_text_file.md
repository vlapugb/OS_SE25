# POSIX: понятия на примере текстового файла

Portable Operating System Interface рассматривает текстовый файл как последовательность байтов, организованных в строки, где каждая строка завершается символом перевода строки с кодом десятичное десять в кодировке American Standard Code for Information Interchange. В такой модели нет встроенных указателей на длину, поэтому любое приложение, опираясь на системные вызовы чтения, может последовательно обрабатывать файл как поток байтов, не заботясь о внутренней структуре. В отличие от операционных систем семейства Microsoft Windows, где строка заканчивается двумя байтами — символами возврата каретки и перевода строки, переносимый формат использует один символ, что упрощает конвейеры обработки. Если файл создан на другой платформе, разработчику нужно явно конвертировать окончания строк, иначе утилиты сравнения или компиляторы могут выдавать неожиданные результаты.

Для конвертации удобно применять потоковый фильтр или специализированный инструмент:

```
tr '\r' '\n' < win.txt > unix.txt
fromdos input.txt > output.txt
```

Метаданные файла — тип, права доступа, владелец, группа, размер, временные метки, количество жестких ссылок — хранятся в inode и доступны через системные вызовы запроса статуса. Проверить их можно командой, которая покажет, как маска прав и идентификаторы владельца влияют на доступность чтения и записи:

```
stat sample.txt
```

Содержимое без интерпретации символов удобно просматривать в шестнадцатеричном виде, чтобы убедиться в отсутствии скрытых байтов, или диагностировать кодировку через универсальный идентификатор типов:

```
od -An -tx1 -N64 sample.txt
file sample.txt
```

Стандарт переносимости не накладывает ограничения на максимальную длину строки, поэтому программы обязаны корректно работать с длинными строками, читая файл блоками и проверяя количество прочитанных байтов, а не рассчитывая на фиксированные буферы. При обработке многобайтных кодировок, таких как UTF-8, необходимо избегать обрезки байтовых последовательностей в середине символа; для этого используют библиотеки преобразования или потоковые команды с пониманием кодировок. Пример перекодирования из устаревшей кодовой страницы Windows в универсальный формат:

```
iconv -f CP1251 -t UTF-8 input.txt > output.txt
```

Для подсчета строк и символов без загрузки в память подходит утилита, а выборочные фрагменты можно получить, не нарушая структуру файла или наблюдать обновления в реальном времени при анализе логов:

```
wc -l -m sample.txt
sed -n '1,10p' sample.txt
tail -f sample.txt
```

При записи важно помнить о понятии атомарного добавления: если файл открыт с флагом добавления, то каждый вызов записи добавляет данные в конец как неделимую операцию, предотвращая перемешивание байтов между процессами. Чтобы убедиться, что программа работает с файловым интерфейсом корректно, можно трассировать системные вызовы чтения и записи:

```
strace -e trace=read,write cat sample.txt
```

Эта проверка показывает, что файл обрабатывается как поток байтов, а сигналы конца файла и коды ошибок учитываются должным образом. Текстовый файл в переносимой модели не требует завершающего нулевого байта, как это принято в некоторых языках программирования, поэтому при чтении необходимо опираться только на возвращаемое количество байтов. Управление буферизацией тоже критично: приложения могут использовать буферированное чтение для эффективности, но должны сбрасывать буферы при необходимости синхронного отображения данных на диск.

При совместной работе с пайплайнами оболочки важно учитывать, что утилиты должны корректно читать из стандартного ввода и писать в стандартный вывод, соблюдая ту же модель текстовых строк; благодаря этому конвейеры остаются переносимыми между системами. Разработчик должен учитывать права доступа: если файл принадлежит другому пользователю и не имеет соответствующих прав, попытка открытия завершится ошибкой, которую нужно обрабатывать. Наблюдать за открытыми файловыми дескрипторами процесса можно через псевдофайловую систему, что помогает понять, какие файлы читаются или пишутся в момент времени:

```
ls -l /proc/$$/fd
```

В результате текстовый файл в представлении переносимого интерфейса — это минималистичная и прозрачная сущность: поток байтов с четким символом конца строки, окруженный метаданными в файловой системе. Грамотное обращение с ним требует строгого учета кодировок, прав доступа, атомарности записи и корректной обработки длинных строк, чтобы на любой системе, соответствующей стандарту, результат работы программы был предсказуемым и корректным.
