<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

# Классические задачи планирования

## Введение в общую проблему  (Из лекций)

Мы хотим распределять задачи за эффективное время

Есть два типов задач/тасков (это то, что говорил КК)
- Online
Это те задачи, которые Scheduler на ходу распределяет, изначально информации о них неизвестно
- Offline
Противоположность предыдущего типа, знаем всё о тасках, например, время выполнения

## Конкретный пример

[Вспомним задачу о рюкзаке](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5)

Условие выглядит так: необходимо уложить коробки в ранец ограниченной вместимостью так, чтобы стоимость уложенных коробок была максимальной

Представьте, что ранцы - это CPU , а коробки - это таски, где их приоритет в системе является их стоимостью

И вы возможно вспомните, что она является... NP-полной

## Немного математики

Сейчас узнаем, что такое NP-полные задачи, однако перед этим давайте вспомним пару определений (или скипнете их всех)

### Задача

Задача - это алгоритм, который в результате ввода даёт ответ да или нет.

<img width="400" height="268" alt="image" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Decision_Problem.svg/500px-Decision_Problem.svg.png" />

Формально, под задачей (decision problem) понимается принадлежность элемента множеству

Дано множество строк $L$ (язык), принадлежит $w \in \Sigma^*$ множеству $L$?

### Сводимость задачи

Мы хотим определить некое отношение между задачи, которое сравнивало их сложность

Определение: (Many-one relation)

Дано два языка (множество строк) имеют отношение $L_1 \leq L_2 \Leftrightarrow$ , если

$\exists f : L_1 \rightarrow L_2$ - вычислимая на машине Тьюринга функция, такая что

$\forall w \in \Sigma^*, (w \in L_1 \Leftrightarrow f(w) \in L_2)$

$L_1 \leq_p L_2 $ - отношение по Карпу, если $f$ вычисляется за полиминальное время

### NP

NP - множество языков, которые решаются на недетерминированной мишине Тьюринга за полиминальное время

### NP-полнота

Задача $L$ является NP-полной, если

1) $L$ является NP задачей

2) Для любой задача $L'$ из NP выполняется $L' \leq_p L$

### К чему это
NP-полные задачи - считаются самыми сложными из NP

Проблема в том, что мы пока знаем решение таких задачи только за экспоненциальное время.

Ни в коем случае не говорите, что нет полимининального алгоритма.
Говорите, что мы просто пока *незнаем* такого полиминального алгоритма.

КК точно вас спросят про определение NP-полной задачи

## Диспетчер и планировщик
Планировщик (Scheduler) - это часть операционной системы, это часть операционной системы, которая решает, какой процесс будет запущен в определенный момент времени на конкретном CPU. Платформенно независимый

Диспетчер (Dispatcher) - это модуль, который передает управление процессором процессу, выбранному краткосрочным планировщиком. Занимается низко-уровневыми вещами, чтобы вообще запустить выбранный процесс. Платформенно зависимый

| Планировщик                                                | Диспетчер                                                                                                                                    |
|------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| Есть три типа: долгосрочный, краткосрочный, среднесрочный. | Не имеет типов                                                                                                                               |
| Ни от кого не зависит                                          | Зависит от планировщика                                                                                                                      |
| Отличается алгоритмом (Round-Robin, FIFO, etcч)            | Не имеет конкретного алгоритма                                                                                                               |
| Занимается выбором процессов                               | Также отвечает за: переключение контекста, переключение в пользовательский режим, переход в нужное место при повторном перезапуске процесса. |
|                                                            |                                                                                                                                              |

## Ещё определения
Task (задача) -процесс или поток, управляемый системой планирования ОС

Starvation (Голод) - Это такая неприятная ситуация, когда процессу не достается ресурсов для выполнения

Deadline - Доп условие к таске, которое говорит, за сколько оно должно быть обработано(хоть доли секунды, хоть часы).

Приоритет - численное значение, определяющее важность задачи для планировщика

## **Главные задачи планирования в ОС**

### **1. Распределение ресурсов (Resource Allocation)**
- **Цель:** Справедливо распределить CPU время между всеми процессами
- **Проблема:** Ограниченный ресурс (CPU) vs множество конкурентов
- **Пример:** CFS в Linux использует `vruntime` для пропорционального распределения

### **2. Обеспечение отзывчивости (Responsiveness)**
- **Цель:** Быстро реагировать на интерактивные события (клики, нажатия клавиш)
- **Проблема:** Интерактивные задачи vs CPU-bound задачи
- **Решение:** Приоритет для I/O-bound задач, короткие кванты времени

### **3. Гарантия дедлайнов (Deadline Guarantees)**
- **Цель:** Выполнить критичные задачи к определенному времени
- **Актуально:** Real-time системы (робототехника, аудио/видео)
- **Реализация:** `SCHED_DEADLINE` с алгоритмом EDF (Earliest Deadline First)

### **4. Предотвращение голодания (Starvation Prevention)**
- **Цель:** Ни одна задача не должна вечно ждать ресурсов
- **Проблема:** Высокоприоритетные задачи монополизируют CPU
- **Решение:** Aging (повышение приоритета со временем), ограничение RT задач

### **5. Энергоэффективность (Energy Efficiency)**
- **Цель:** Минимизировать энергопотребление
- **Техники:** Consolidation (сбор нагрузки на few ядрах), race-to-idle, DVFS
- **Пример:** EAS (Energy Aware Scheduler) в Linux для мобильных устройств

### **6. Предсказуемость (Predictability)**
- **Цель:** Гарантировать время отклика для real-time систем
- **Реализация:** Статические приоритеты (`SCHED_FIFO`, `SCHED_RR`)
- **Ограничение:** Обеспечить детерминированное поведение

### **Ключевой компромисс в планировании:**

Справедливость (Fairness) ↔ Эффективность (Throughput)

Отзывчивость (Responsiveness) ↔ Предсказуемость (Predictability)

Энергосбережение (Energy Saving) ↔ Производительность (Performance)

## Стратегии
### 1. **SCHED_FIFO (First-In-First-Out)**

#### Основной принцип
**"Выполняй, пока не закончишь или не отдашь CPU добровольно"**

#### Правила:
1. **Выполняется непрерывно**, пока:
   - Не завершится (exit)
   - Не перейдет в состояние ожидания (sleep, блокировка на I/O)
   - Не вызовет `sched_yield()` для добровольной передачи CPU
   - Не будет **вытеснена задачей с более высоким приоритетом**

2. **Очереди:** Для каждого приоритета своя FIFO-очередь
3. **При появлении** задачи с более высоким приоритетом — немедленное вытеснение
4. **При равных приоритетах** — новая задача становится в конец очереди
### 2. **SCHED_RR (Round Robin)**

#### Основной принцип
**"Выполняй, но дели CPU с другими задачами того же приоритета"**

#### Правила:
1. **Имеет квант времени** (timeslice), обычно 100 мс
2. **Выполняется**, пока:
   - Не исчерпает квант времени
   - Не завершится
   - Не перейдет в ожидание
   - Не будет вытеснена задачей с более высоким приоритетом

3. **При исчерпании кванта:** Задача перемещается в **конец очереди** своего приоритета
4. **Round Robin** работает только внутри одного уровня приоритета

#### Детальное сравнение

| Характеристика            | **SCHED_FIFO**                                         | **SCHED_RR**                                     |
|---------------------------|--------------------------------------------------------|--------------------------------------------------|
| **Основное правило**      | Выполнять до завершения или добровольного освобождения | Выполнять в течение кванта времени               |
| **Квант времени**         | Нет (бесконечный)                                      | Есть (обычно 100 мс)                             |
| **При исчерпании кванта** | Неприменимо                                            | В конец очереди своего приоритета                |
| **Очередь задач**         | FIFO для каждого приоритета                            | Round-robin для каждого приоритета               |
| **Вытеснение**            | Только более высоким приоритетом                       | Более высоким приоритетом или исчерпанием кванта |
| **Предсказуемость**       | Высокая (детерминированная)                            | Ниже (зависит от количества задач в уровне)      |
| **Риск голодания**        | Высокий (может захватить CPU)                          | Низкий (делится с задачами того же уровня)       |
| **Использование**         | Критичные hard real-time задачи                        | Менее критичные soft real-time задачи            |

## Эволюция решений в Linux

1. **O(1) scheduler (2.6):** Решил проблему O(n) поиска, но создал проблемы с интерактивностью
2. **CFS (2.6.23+):** Решил проблему справедливости через vruntime
3. **Autogroup (2.6.38):** Решил проблему interactive vs batch для сессий
4. **SCHED_DEADLINE (3.14):** Решил проблему планирования с гарантиями сроков
5. **EAS (4.x):** Решает проблему энергоэффективности
6. **SCHED_EXT (6.x+):** Пытается решить проблему гибкости (подключаемые политики)

## Разные планировщики Linux
O(n) Scheduler (Linux 2.4 и ранее)

    Один линейный список всех готовых задач

    O(n) на выбор задачи — обход всего списка

    Приоритеты: Статические, от 0 до 140

    Простейший round-robin внутри каждого приоритета

    Не масштабировался для многопроцессорных систем

    Большие задержки для интерактивных задач

O(1) scheduler (Linux 2.6 - 2.6.22):

    Фиксированные приоритетные очереди

    Быстрый (O(1) на операции)

    Но плохая справедливость для интерактивных задач

CFS (текущий по умолчанию):

    Красно-черное дерево по vruntime

    O(log n) на операцию (медленнее)

    Но гораздо лучше fairness

## Классы задач
Классы планирования в Linux — это **иерархия приоритетов**, где:

1. **STOP** — не для планирования, а для управления CPU
2. **Deadline** — "гарантированное завершение к сроку" (самый высокий приоритет пользовательских задач)
3. **Real-Time** — "предсказуемое время отклика" (FIFO для детерминизма, RR для чередования)
4. **Normal** — "справедливость для всех" (CFS с динамическими приоритетами)
5. **Idle** — "когда делать нечего" (энергосбережение)

## **Вывод**
**Планирование в ОС** — это решение **NP-полной задачи** (аналогично задаче о рюкзаке), где нужно распределить ограниченные ресурсы CPU между конкурентными задачами с разными приоритетами, дедлайнами и требованиями.

**Ключевые принципы:**
1. **Компромисс** — между справедливостью и эффективностью, отзывчивостью и предсказуемостью
2. **Иерархия** — классы задач от критичных (Deadline/RT) до фоновых (Idle)
3. **Эвристики** — вместо оптимальных решений (CFS, O(1), FIFO, RR)
4. **Предотвращение проблем** — голодания, инверсии приоритетов, convoy-эффекта
