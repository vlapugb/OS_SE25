# Понятие процесса. Жизненный цикл. Модель fork/exec

Процесс в ОС — это выполняющаяся программа вместе с адресным пространством, таблицей дескрипторов файлов, набором регистров, сигналами и счетчиками использования ресурсов, которые ядро отслеживает для планирования и управления. 
**Если говорить проще: процесс - исполняемая программа + её контекст**
 Жизненный цикл проходит через состояния: новый процесс создается и готовится к запуску, готовый ожидает квант процессорного времени, выполняющийся занимает ядро, ожидающий блокируется на вводе-выводе или синхронизации, завершенный ждет передачи статуса родителю и в этот момент считается зомби. Наблюдать текущую картину можно через таблицу процессов и древовидный вывод:
```
ps -o pid,ppid,state,cmd
pstree -p
```
То как выглядит структура процесса в Linux (для гиков):
    struct task_struct {
        /* --- Процессы и идентификаторы --- */
        pid_t pid;                  // PID процесса
        pid_t tgid;                 // ID группы потоков
        struct task_struct *parent;       // логический родитель
        struct list_head children;        // список детей
        struct list_head sibling;         // следующий ребёнок того же родителя

        /* --- Планирование (scheduler) --- */
        int prio;                   // приоритет
        int static_prio;            // базовый приоритет
        unsigned int policy;        // SCHED_OTHER / FIFO / RR …
        struct sched_entity se;     // сущность для CFS

        /* --- Управление памятью --- */
        struct mm_struct *mm;       // адресное пространство
        struct mm_struct *active_mm;// используется ядром для kernel threads

        /* --- Состояние процесса --- */
        volatile long state;        // TASK_RUNNING, TASK_INTERRUPTIBLE …
        int exit_state;             // EXIT_ZOMBIE и др.
        int exit_code;              // код завершения

        /* --- Время --- */
        u64 utime;                  // пользовательское время
        u64 stime;                  // системное время
        u64 start_time;             // время запуска

        /* --- Сигналы --- */
        sigset_t blocked;           // блокированные сигналы
        struct sigpending pending;  // ожидающие сигналы
        struct signal_struct *signal; // общие для всей группы
        struct sighand_struct *sighand;// обработчики сигналов

        /* --- Файлы и ресурсы --- */
        struct fs_struct *fs;       // cwd, rootdir
        struct files_struct *files; // таблица файлов

        /* --- Разное — accounting, namespaces, cgroups --- */
        struct nsproxy *nsproxy;    // namespace’ы
        struct cgroup_subsys_state *cgroups;
        struct rlimit rlim[RLIM_NLIMITS];

        /* --- Имя процесса --- */
        char comm[TASK_COMM_LEN];   // максимум 16 байт
    };

# Созданиe нового процесса - fork/exec 


### 1. Порожение процесса (fork())

Создание нового процесса выполняется через системный вызов fork().
Ядро создаёт дочерний процесс PID₂, который является почти полной копией процесса-родителя PID₁.

**Что наследует дочерний процесс:**
 - практически всю память (состояние, стек, данные, код)
- контекст выполнения (регистры и их значения)
- атрибуты процесса (приоритет, сигналы, маски, рабочий каталог и т.д.)
- открытые файловые дескрипторы
- содержимое программы (код + библиотеки)
**Что не наследуется:**
- PID — у процесса всегда уникальный идентификатор

Обе программы — родитель и ребёнок — продолжают выполнение одной и той же инструкции, но получают разные значения возврата fork():
- родитель → PID ребёнка
- ребёнок → 0
Благодаря этому далее их ветки выполнения могут расходиться.
### 2. Exec()
Чаще всего сразу после порождения дочернего процесса выполняется системный вызов `execve()`, заменяющий текущее адресное пространство новым исполняемым образом.
На этом этапе ядро загружает файл в формате ELF (Executable and Linkable Format), мапирует его сегменты кода, данных и стека, инициализирует структуру аргументов командной строки, переменные окружения и точку входа. При этом все открытые файловые дескрипторы сохраняются, за исключением тех, что помечены флагом `close-on-exec`.
### 3. Завершение процесса (exit())

Процесс завершает работу через вызов exit(status), передавая ядру код завершения status.
**После вызова:**
- процесс прекращает выполнение,
- освобождает почти все ресурсы,
- но остается запись в таблице процессов до тех пор, пока родитель не заберёт его статус.

**Состояние Z (zombie)**

Время между завершением процесса и вызовом родителем wait() называется zombie-состоянием.
В этот момент процесс:

- уже не выполняется,
- но его PID и код завершения ещё хранятся в ядре,
- в ps отображается со статусом Z.

Zombie — это не активный процесс, а лишь административная запись, хранящая статус завершения.

### 3. Ожидание завершения (wait())

Родительский процесс должен вызвать wait(), чтобы:
- получить код завершения дочернего процесса,
- позволить ядру окончательно удалить запись о нём.
Только после wait() зомби исчезает.

### 4. Что происходит при смерти родителя?

Если родитель завершился раньше ребёнка:
у дочернего процесса не будет зомби-состояния,
даже когда он завершится,

потому что “осиротевший” процесс автоматически получает нового родителя.

Прийомный родитель — процесс init (PID = 1)
Init-процесс:
является предком всех процессов в системе,
автоматически вызывает wait() для всех сиpот,
тем самым очищает их zombie-записи.
Поэтому “осиротевшие” процессы по завершении не остаются зомби — init за ними ухаживает
![[Pasted image 20251203181953.png]]
```
strace -f -e trace=fork,execve,exit sleep 1
```
Иногда может быть полезно использовать kill или killall для отправки сигналов процессам
```
kill -SIGTERM <pid>
```

Интерактивные оболочки поддерживают управление заданиями: процессы можно запускать в фоне, приостанавливать комбинацией клавиш, выводить список и возвращать на передний план. Пример фонового задания и ожидания его завершения:

```
sleep 100 &
jobs
wait %1
```

Современные системы дополняют модель процессами с пространствами имен и контрольными группами, которые изолируют видимость ресурсов и ограничивают их потребление, что широко используется в контейнерах. При этом базовая семантика процессов — идентификатор, родитель, состояние, дескрипторы — сохраняется. Для производительности и безопасности важно контролировать наследование ресурсов: не закрытые дескрипторы могут удерживать файлы и сокеты, а неправильно настроенные маски сигналов мешают завершению. Планировщик распределяет процессорное время между готовыми процессами, учитывая приоритеты и квоты, и меняет состояние процесса на выполняющееся при выделении квантов. Измерять использование ресурсов и таймеры позволяют счетчики, доступные через псевдофайловые системы или специализированные вызовы. Код выхода процесса — важный канал обратной связи: ноль означает успех, ненулевое значение описывает тип ошибки, и цепочки процессов должны его анализировать.

Отдельно стоит отметить различие между процессами и потоками: потоки разделяют адресное пространство и большинство ресурсов, но имеют собственные идентификаторы и стеки, а ядро планирует их так же, как процессы, что позволяет применять те же механизмы сигналов, ожидания и квот. При копировании процесса с большим адресным пространством механизм копирования при записи особенно важен: без него создание процесса занимало бы непропорционально много времени и памяти, а с ним фактическое дублирование происходит только при записи страниц. В системах реального времени разработчики могут управлять приоритетами и политиками планирования процессов, чтобы обеспечить детерминированную реакцию на события, но должны внимательно следить за наследованием этих параметров дочерними процессами. В административной практике полезно использовать инструменты измерения и ограничения ресурсов, чтобы ранние признаки утечек или зависаний процессов были заметны и не приводили к исчерпанию таблиц или памяти.

Модели потоков, которые встречаются в ОС и рантаймах:
- **1:1** — каждое пользовательское представление потока сопоставлено с ядровым тредом (классическая `pthread_create` в Linux).
- **N:1** — множество пользовательских потоков мультиплексируется на один ядровой поток (green threads, fiber‑реализации), что уменьшает накладные расходы, но блокирующий системный вызов останавливает всю группу.
- **N:M** — гибридные решения, где несколько пользовательских потоков распределяются по пулу ядровых тредов.

Для синхронизации потоков в user space используют мьютексы на базе **futex**, а в более низкоуровневых случаях — **спинлоки**, работающие на атомарных инструкциях (`cmpxchg`). Спинлок крутится в цикле (часто с инструкцией `pause` на x86), не отдавая квант, и поэтому годится для очень коротких критических секций.

Итоговая картина: процесс — фундаментальная единица изоляции и планирования, с четким жизненным циклом от создания через копирование, возможную замену исполняемым образом, выполнение, обработку сигналов и завершение. Понимание этих этапов позволяет разработчику строить надежные сервисы, правильно управлять ресурсами, избегать утечек и зомби, а также использовать возможности изоляции и контроля, предоставляемые современными ядрами.
