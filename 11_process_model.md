# Понятие процесса. Жизненный цикл. Модель fork/exec

Процесс в переносимой операционной системе — это выполняющаяся программа вместе с адресным пространством, таблицей дескрипторов файлов, набором регистров, сигналами и счетчиками использования ресурсов, которые ядро отслеживает для планирования и управления. Жизненный цикл проходит через состояния: новый процесс создается и готовится к запуску, готовый ожидает квант процессорного времени, выполняющийся занимает ядро, ожидающий блокируется на вводе-выводе или синхронизации, завершенный ждет передачи статуса родителю и в этот момент считается зомби. Наблюдать текущую картину можно через таблицу процессов и древовидный вывод:

```
ps -o pid,ppid,state,cmd
pstree -p
```

Создание нового процесса реализуется через копирование текущего контекста, называемое моделью копирования, которая дублирует адресное пространство и дескрипторы, используя ленивое копирование страниц для эффективности: пока ни один процесс не пишет, страницы разделяются. Системный вызов создания возвращает дважды: в родителе с идентификатором дочернего процесса и в дочернем с нулем. Это позволяет сразу различать пути выполнения. Обычно следующий шаг — замена адресного пространства новым исполняемым образом через вызов выполнения, который загружает файл в формате Executable and Linkable Format, настраивает сегменты кода, данных и стека, подготавливает таблицы символов, аргументы, переменные окружения и точки входа, но сохраняет открытые дескрипторы, если они не помечены флагом закрытия при выполнении. Наблюдать последовательность системных вызовов создания и замещения можно трассировкой:

```
strace -f -e trace=fork,execve,exit sleep 1
```

После замещения процесс начинает выполнение кода из нового файла, и его идентификатор остается тем же. Жизненный цикл завершается вызовом завершения, который устанавливает код выхода и освобождает ресурсы, оставляя запись для родителя. Родитель должен вызвать ожидание, чтобы прочитать статус и удалить запись, иначе зомби будут накапливаться, занимая записи таблицы процессов. Если родитель завершается раньше, дочерний процесс усыновляется специальным процессом с идентификатором один, который периодически собирает статусы. Управление процессом осуществляется через сигналы, позволяющие прерывать, завершать или приостанавливать выполнение. Послать сигнал завершения можно командой, а для наблюдения за реакцией программы полезно установить обработчики сигналов:

```
kill -SIGTERM <pid>
```

Интерактивные оболочки поддерживают управление заданиями: процессы можно запускать в фоне, приостанавливать комбинацией клавиш, выводить список и возвращать на передний план. Пример фонового задания и ожидания его завершения:

```
sleep 100 &
jobs
wait %1
```

Современные системы дополняют модель процессами с пространствами имен и контрольными группами, которые изолируют видимость ресурсов и ограничивают их потребление, что широко используется в контейнерах. При этом базовая семантика процессов — идентификатор, родитель, состояние, дескрипторы — сохраняется. Для производительности и безопасности важно контролировать наследование ресурсов: не закрытые дескрипторы могут удерживать файлы и сокеты, а неправильно настроенные маски сигналов мешают завершению. Планировщик распределяет процессорное время между готовыми процессами, учитывая приоритеты и квоты, и меняет состояние процесса на выполняющееся при выделении квантов. Измерять использование ресурсов и таймеры позволяют счетчики, доступные через псевдофайловые системы или специализированные вызовы. Код выхода процесса — важный канал обратной связи: ноль означает успех, ненулевое значение описывает тип ошибки, и цепочки процессов должны его анализировать.

Отдельно стоит отметить различие между процессами и потоками: потоки разделяют адресное пространство и большинство ресурсов, но имеют собственные идентификаторы и стеки, а ядро планирует их так же, как процессы, что позволяет применять те же механизмы сигналов, ожидания и квот. При копировании процесса с большим адресным пространством механизм копирования при записи особенно важен: без него создание процесса занимало бы непропорционально много времени и памяти, а с ним фактическое дублирование происходит только при записи страниц. В системах реального времени разработчики могут управлять приоритетами и политиками планирования процессов, чтобы обеспечить детерминированную реакцию на события, но должны внимательно следить за наследованием этих параметров дочерними процессами. В административной практике полезно использовать инструменты измерения и ограничения ресурсов, чтобы ранние признаки утечек или зависаний процессов были заметны и не приводили к исчерпанию таблиц или памяти.

Итоговая картина: процесс — фундаментальная единица изоляции и планирования, с четким жизненным циклом от создания через копирование, возможную замену исполняемым образом, выполнение, обработку сигналов и завершение. Понимание этих этапов позволяет разработчику строить надежные сервисы, правильно управлять ресурсами, избегать утечек и зомби, а также использовать возможности изоляции и контроля, предоставляемые современными ядрами.
