# Билет: GOT и PLT. Понятие файлового дескриптора

## 1. Контекст: ELF, динамическая компоновка и зачем нужны GOT/PLT

В современных Unix-подобных ОС (Linux, *BSD и др.) исполняемые файлы и библиотеки обычно имеют формат **ELF** (Executable and Linkable Format).

Основные идеи:

- Код использует **функции и глобальные переменные**, которые могут находиться:
  - в самом исполняемом файле;
  - во внешних динамических библиотеках (`libc.so`, `libm.so` и т.п.).
- На этапе компиляции **неизвестно**, по каким *реальным* адресам в памяти окажутся:
  - функции библиотек;
  - глобальные переменные.
- При загрузке программы динамический компоновщик (`ld-linux.so`) должен **связать** все обращения к внешним объектам с их фактическими адресами.

Чтобы это сделать эффективно и с поддержкой **позиционно-независимого кода (PIC/PIE)**, используются две структуры:

- **GOT (Global Offset Table)** — глобальная таблица смещений;
- **PLT (Procedure Linkage Table)** — таблица процедурных переходов.

---

## 2. GOT (Global Offset Table)

### 2.1. Определение

**GOT (Global Offset Table)** — это таблица в памяти процесса (обычно секции `.got` и `.got.plt` ELF-файла), содержащая:

- **адреса глобальных объектов**:
  - глобальных и статических переменных;
  - функций (особенно из внешних библиотек, в связке с PLT).
- Для кода, собранного как PIC (позиционно-независимый), доступ к глобалу идёт **через запись в GOT**, а не напрямик по константному адресу.

Идея:

> Вместо того, чтобы зашивать в код абсолютный адрес переменной/функции, мы храним в GOT *указатель на них*. Код знает только **смещение** записи в GOT относительно базового адреса.

### 2.2. Пример: доступ к глобальной переменной через GOT

Пусть есть глобальная переменная в Си:

```c
int global_var = 42;
```

Компилятор при генерации позиционно-независимого кода не может писать прямо:

```asm
movl    global_var(%rip), %eax   // абсолютный адрес
```

Он использует **GOT** (примерно на x86-64, упрощённо):

```asm
movq    global_var@GOTPCREL(%rip), %rax  ; загрузить адрес записи в GOT
movl    (%rax), %eax                     ; прочитать значение по указателю
```

Где:

- `global_var@GOTPCREL` — это релокация, указывающая на **ячейку GOT**, соответствующую `global_var`.
- В эту ячейку при загрузке динамический линкер запишет **фактический адрес** `global_var` в памяти процесса.

Таким образом:

- Код не зависит от абсолютных адресов.
- При перемещении всего модуля (PIE) достаточно скорректировать GOT.

### 2.3. Структура и заполнение GOT

GOT — это **массив указателей**. Для каждой внешней сущности (глобала/функции) есть **запись**:

- до релокации (до инициализации линкером) там может быть ноль или некий служебный адрес;
- динамический компоновщик, проходя по таблице релокаций, **записывает реальные адреса** в соответствующие ячейки GOT.

Для функций, вызываемых через PLT, есть особая часть: **`.got.plt`**, которая содержит:

- служебные записи для механизма ленивой (lazy) загрузки;
- указатели, сначала направленные на «резолвер» динамического линкера, затем — на реальные адреса функций.

---

## 3. PLT (Procedure Linkage Table)

### 3.1. Определение

**PLT (Procedure Linkage Table)** — это участок кода (секция `.plt` в ELF), содержащий **небольшие фрагменты (stubs)** для вызова функций, находящихся в **динамических библиотеках**.

Для каждой импортируемой функции (например, `printf`, `malloc`) в PLT есть **мини-функция**:

- по адресу `printf@plt` хранится код, который:
  - либо немедленно переходит по адресу из GOT (если уже разрешено);
  - либо (при первом вызове) вызывает динамический линкер, который находит настоящую функцию и обновляет запись в GOT.

Идея:

> Вызов внешней функции → переход в PLT-заглушку → она использует GOT → при необходимости вызывает динамический линкер.

### 3.2. Механизм ленивого связывания (lazy binding)

Чтобы не связывать сразу все импортируемые функции (это дорого), используется **ленивая загрузка**:

1. При загрузке программы:
   - динамический компоновщик **не ищет сразу все адреса функций**;
   - записи в `.got.plt` для функций указывают на специальную **общую точку входа резолвера** (обычно `PLT0`).

2. Первый вызов функции:
   - программа вызывает `printf` → попадает в `printf@plt`;
   - `printf@plt`:
     - через записи в `.got.plt` и специальный фрейм вызывает динамический линкер;
     - передаёт ему идентификатор нужного символа (`printf`).
   - динамический линкер находит эту функцию в подключенных библиотеках:
     - записывает **истинный адрес** `printf` в соответствующую запись GOT;
     - возвращает управление.

3. Последующие вызовы:
   - `printf@plt` теперь просто делает **непосредственный переход по адресу** из GOT (который уже указывает на реальную `printf`).
   - Линкер больше не вызывается — всё работает быстро.

Таким образом:

- PLT служит «прослойкой» между вызовами в программе и таблицей GOT;
- ленивое связывание экономит время старта программы.

### 3.3. Схематически (словесная диаграмма)

Для вызова `printf`:

1. Ваш код:  
   **`call printf@plt`**
2. В `printf@plt`:
   - читает указатель `GOT[printf]`:
     - если там уже реальный адрес → прямой `jmp *GOT[printf]`;
     - если там адрес резолвера → специальная последовательность, вызывающая динамический линкер.
3. Линкер находит символ:
   - записывает реальный адрес в `GOT[printf]`;
   - в следующий раз PLT сразу прыгает в настоящую `printf`.

---

## 4. Взаимодействие GOT и PLT

Упрощённо:

- **GOT** — "таблица указателей" на:
  - глобальные переменные;
  - функции (в т.ч. из динамических библиотек).
- **PLT** — "таблица переходов" (кусочки кода), которые:
  - используют записи GOT для вызова;
  - при необходимости вызывают динамический линкер для разрешения адреса.

Связка:

1. Компилятор генерирует вызов внешней функции как `call имя@plt`.
2. В PLT-записи хранится код, который:
   - обращается к соответствующей записи в `.got.plt`;
   - при первом вызове даёт динамическому линкеру возможность найти символ и обновить GOT.
3. После первого вызова:
   - PLT просто прыгает по уже обновлённому адресу в GOT.

---

## 5. Безопасностные аспекты (кратко)

GOT и PLT являются интересной целью для атак:

- **Перезапись GOT** (GOT overwrite):
  - если злоумышленник может изменить запись в GOT (например, через уязвимость записи в память), он может перенаправить вызовы `printf` и др. на свой код.
- **ret2plt**:
  - в эксплойтах используют адреса записей PLT, чтобы вызвать нужные функции (например, `system`) при ограничениях на адреса памяти.

Для защиты используются механизмы:

- **RELRO (Relocation Read-Only)**:
  - после завершения релокаций сегмент с GOT делают read-only;
  - затрудняет перезапись GOT.
- Совместно с ASLR, NX, stack canaries и др. повышается общая безопасность.

---
## 6. Краткое резюме по билету

1. **GOT (Global Offset Table)**:
   - таблица указателей на глобальные данные и функции;
   - используется для позиционно-независимого кода;
   - динамический компоновщик заполняет её реальными адресами при загрузке (и при ленивом связывании).

2. **PLT (Procedure Linkage Table)**:
   - участок кода (таблица переходов) для вызова функций из динамических библиотек;
   - каждая запись PLT — маленький stub, использующий записи GOT;
   - поддерживает ленивое связывание: первый вызов вызывает линкер, далее — прямой переход.

3. **Связка GOT + PLT**:
   - вызов внешней функции → запись PLT → запись GOT;
   - при первом вызове GOT-запись заполняется реальным адресом, далее используется напрямую.
