# GOT и PLT

Глобальная таблица смещений, или Global Offset Table, и таблица процедурных переходов, или Procedure Linkage Table, составляют механизм косвенного доступа к внешним символам в исполняемых файлах и динамических библиотеках, собранных с позиционно независимым кодом. Позиционно независимый код не может зашить абсолютные адреса функций и данных, потому что библиотека или сам исполняемый файл могут быть размещены динамическим загрузчиком по разным адресам в разных процессах из-за произвольного размещения адресного пространства. Вместо жестких адресов компоновщик оставляет записи релокаций, которые динамический загрузчик применяет к таблице смещений при загрузке. Каждая запись таблицы смещений представляет собой слот в памяти, куда помещается вычисленный адрес внешнего объекта, будь то функция или глобальная переменная.

Таблица процедурных переходов — это набор маленьких оберток в машинном коде, каждая из которых загружает адрес из таблицы смещений и совершает переход, позволяя разделить код на этапы: первая активация функции может вызвать специальный код разрешения, а последующие будут прыгать напрямую. Типичный процесс ленивой привязки выглядит так: код вызывает функцию внешней библиотеки, управление попадает в соответствующий слот таблицы процедурных переходов, там выполняется прыжок на часть кода загрузчика, который по индексу записи ищет реальный адрес в динамических структурах, записывает его в таблицу смещений и возвращается. Вторая и последующие итерации читают уже заполненный слот, обходя загрузчик, что экономит время при долгоживущих процессах.

Детали можно увидеть через анализ объекта и содержимого таблиц:

```
objdump -d -Mintel ./app | grep "@plt" -A3
objdump -s -j .got.plt ./app
readelf -r ./app
```

Релокации типа jump slot или global data описывают, какой символ должен быть разрешен и куда записать адрес. При включенном ленивом связывании релокации jump slot применяются при первом вызове, но разработчик может потребовать немедленное разрешение всех символов для сокращения задержек на горячих путях или усиления безопасности. Это делается переменной окружения, запрещающей ленивую привязку, или флагом компоновщика, включающим режим немедленных релокаций:

```
LD_BIND_NOW=1 ./app
```

Стратегия немедленного связывания снижает риск атак через подмену таблицы смещений после первого вызова, потому что таблица может быть переведена в только-чтение сразу после инициализации, используя механизм защиты relocations read-only. Дополнительно системы используют произвольное расположение адресного пространства, что делает предсказание адресов таблиц сложным для злоумышленника. Несмотря на защиту, разработчик должен помнить, что записи таблицы смещений содержат данные, а значит при ошибках контроля памяти их можно переписать; поэтому критичные сервисы иногда собирают статически или применяют контроль целостности переходов.

Таблица процедурных переходов также участвует в переопределении символов: механизм предварительной загрузки позволяет подставить свою библиотеку с функцией той же сигнатуры, и загрузчик запишет адрес этой реализации в таблицу смещений, что используется для профилирования, тестирования или изоляции. Проверить порядок разрешения символов можно отладочной переменной загрузчика:

```
LD_DEBUG=bindings ./app
```

Тонкость: прямые вызовы внутри одной динамической библиотеки могут обходить таблицу процедурных переходов, если компоновщик знает, что символ находится в том же объекте; это чуть дешевле, но уменьшает гибкость переопределения. С точки зрения архитектуры, Global Offset Table и Procedure Linkage Table обеспечивают гибкость динамической линковки, разделение кода и возможность позднего связывания, но добавляют косвенность и небольшие накладные расходы. Опытный разработчик учитывает их влияние на производительность, принимает решение о ленивом или немедленном связывании, анализирует безопасность и использует инструменты проверки, чтобы убедиться, что таблицы заполняются ожидаемыми адресами, а не подменены внешними факторами. Именно этот баланс между гибкостью обновлений и предсказуемостью исполнения делает эти таблицы важным предметом внимания на уровне технического директора или архитектора системного программного обеспечения.
