# Статически разделяемые библиотеки

## 1. Понятие библиотеки

**Библиотека** — это набор уже скомпилированного кода и данных (функций, процедур, констант, таблиц), который может многократно использоваться различными программами.

По способу подключения библиотеки делятся на:
- **Статические библиотеки** (static libraries, обычно `.a` в Unix, `.lib` в Windows);
- **Динамически разделяемые библиотеки** (shared/dynamic libraries, `.so`, `.dll`, `.dylib`).

В этом билете рассматриваем именно **статические библиотеки**.

---

## 2. Определение статической библиотеки

**Статическая библиотека** — это файл, содержащий один или несколько объектных модулей (object files), которые **встраиваются** в исполняемую программу на этапе **линковки**.

Характерные черты:
- библиотека представляет собой **архив объектных файлов**;
- при сборке программы линковщик **копирует** необходимые модули из библиотеки в исполняемый файл;
- в результате получается **самодостаточный** бинарный файл, который не требует наличия этой библиотеки во время выполнения.

Примеры:
- В Linux/Unix: `libm.a`, `libc.a`;
- В Windows: файлы `.lib` статического типа.

---

## 3. Формат и структура статической библиотеки

Обычно статическая библиотека — это **архив** (`ar`-архив в Unix-подобных системах), содержащий:
- заголовок библиотеки;
- таблицу символов (для быстрого поиска);
- набор объектных файлов (`.o`/`.obj`), каждый из которых:
  - содержит машинный код функций;
  - таблицы символов (что экспортируется/импортируется);
  - информацию для линковщика (релокации и т.д.).

Важно: статическая библиотека **не выполняется напрямую**, а используется **только на этапе линковки**.

---

## 4. Процесс использования статической библиотеки

### 4.1. Этапы работы

1. **Компиляция исходных файлов библиотеки**  
   Исходные файлы (например, `math.c`, `util.c`) компилируются в объектные:
   ```bash
   gcc -c math.c   # math.o
   gcc -c util.c   # util.o
   ```

2. **Создание статической библиотеки**  
   Объектные файлы упаковываются в архив:
   ```bash
   ar rcs libmymath.a math.o util.o
   ```

3. **Компиляция и линковка программы с библиотекой**  
   Программа, которая использует функции из библиотеки:
   ```bash
   gcc main.c -L. -lmymath -o program
   ```
   При этом:
   - линковщик находит `libmymath.a`;
   - извлекает из неё **только те объектные файлы**, в которых определены используемые символы (функции, переменные);
   - **копирует** их содержимое в итоговый исполняемый файл `program`.

4. **Запуск программы**  
   Во время выполнения:
   - библиотека **не нужна** — весь код уже включён в `program`;
   - ОС загружает только исполняемый файл.

---

## 5. Связывание (линковка) при использовании статических библиотек

### 5.1. Линковка во время сборки (link-time)

При статическом связывании:
- все внешние символы (функции/переменные), которые программа берёт из библиотеки, разрешаются **на этапе линковки**;
- адреса функций и данных вычисляются заранее;
- в итоговом бинарном файле отсутствуют внешние зависимости вида «нужно подгрузить ещё такую-то библиотеку».

С точки зрения ОС:
- исполняемый файл — **монолитный** набор машинного кода и данных;
- для запуска достаточно загрузить один файл (плюс стандартные системные компоненты).

### 5.2. Выбор модулей из библиотеки

При линковке со статической библиотекой:
- **не весь код** библиотеки попадает в программу;
- линковщик:
  - анализирует символы, которые требуются программе;
  - ищет соответствующие определения в объектных файлах библиотеки;
  - добавляет в итоговый бинарник только те объектные файлы, где используются нужные символы.

Это позволяет:
- не засорять программу ненужным кодом;
- уменьшать размер итогового файла по сравнению с тупым включением всей библиотеки.

---

## 6. Сравнение статических и динамически разделяемых библиотек

Для понимания места статических библиотек в ОС важно сравнить их с динамическими.

### 6.1. Статические библиотеки

- Код библиотеки **копируется** в исполняемый файл **на этапе линковки**.
- Исполняемый файл **самодостаточен** — он не зависит от наличия соответствующей `.a`/`.lib` библиотеки при запуске.
- Изменение исходной библиотеки **не влияет** на уже собранные программы (чтобы использовать новую версию — нужна пересборка).

### 6.2. Динамические библиотеки (для контраста)

- Код библиотеки **не встраивается** в исполняемый файл.
- При запуске программы библиотека **загружается отдельно** (динамическим загрузчиком/линковщиком).
- Один экземпляр библиотеки в памяти может **разделяться между процессами**.
- Обновление библиотеки может сразу повлиять на все программы, которые её используют.

### 6.3. Табличное сравнение

| Характеристика                   | Статическая библиотека                      | Динамическая библиотека                         |
|----------------------------------|---------------------------------------------|-------------------------------------------------|
| Встраивание кода в программу     | Да, на этапе линковки                       | Нет, код загружается отдельно                   |
| Зависимость при запуске          | Нет (всё в одном бинарнике)                 | Требуются `.so`/`.dll`                          |
| Размер исполняемого файла        | Обычно больше                               | Обычно меньше                                   |
| Обновление библиотеки            | Требуется **пересборка** программы          | Обновление библиотеки влияет на все программы  |
| Использование памяти (RAM)       | Код **не разделяется** между процессами     | Код может разделяться                           |
| Версионные конфликты             | Минимальны (каждая программа со своей версией) | Возможны конфликты (DLL hell и т.п.)         |
| Скорость загрузки программы      | Обычно немного быстрее (меньше динамики)    | Может быть чуть медленнее из-за загрузки/линковки |

---

## 7. Преимущества статических библиотек

1. **Самодостаточность исполняемого файла**
   - Для запуска программы достаточно одного бинарника.
   - Удобно для:
     - статически собранных утилит в rescue-системах;
     - встраиваемых систем (embedded);
     - распространения ПО, где тяжело контролировать зависимости.

2. **Отсутствие проблем с версиями библиотек**
   - Программа использует **именно ту версию кода**, с которой была собрана.
   - Обновление системных библиотек не ломает уже собранные программы.

3. **Простота развёртывания**
   - Не нужно устанавливать дополнительные пакеты библиотек.
   - Особенно полезно при переносе на другую машину или в контейнер.

4. **Возможный выигрыш в скорости выполнения**
   - Меньше накладных расходов на динамическую линковку при запуске.
   - В каких-то случаях оптимизации компоновщика могут работать эффективнее.

---

## 8. Недостатки статических библиотек

1. **Больший размер исполняемого файла**
   - Если многие программы используют одну и ту же статическую библиотеку:
     - копия кода будет включена в каждую программу;
     - суммарное потребление дискового пространства возрастёт.

2. **Повышенное потребление RAM**
   - Код одной и той же библиотеки не разделяется между процессами:
     - каждый процесс содержит свою копию кода;
     - суммарное использование памяти больше, чем при динамических библиотеках.

3. **Сложность обновления**
   - Для исправления ошибки (например, уязвимости) в библиотеке:
     - нужно пересобрать **каждую** программу, которая использует эту библиотеку;
     - иначе старые программы останутся с дефектным кодом.

4. **Сложность сопровождения большого числа программ**
   - В большой системе с десятками/сотнями приложений:
     - управление обновлениями статических библиотек может стать трудоёмким;
     - динамические библиотеки в таких случаях удобнее.

---

## 9. Роль статических библиотек в операционных системах

В ОС статические библиотеки используются:
- при сборке **системных утилит**, которые должны работать даже при проблемах с динамическими библиотеками (например, `busybox` или минимальные средства восстановления);
- в **initramfs/initrd** — начальной файловой системе, где важно минимальное количество зависимостей;
- в **встраиваемых системах**, микроконтроллерах, специализированных прошивках, где:
  - нет полноценной системы динамической линковки;
  - важна простота и предсказуемость.

Также статическое связывание может использоваться:
- при сборке программ для контейнеров (чтобы уменьшить зависимость от окружения);
- при распространении программ в виде одного файла (portable-исполнители).

---

## 10. Особенности реализации и настройки

1. **Ключи компилятора/линковщика**
   - В GCC/Clang:
     - `-static` — принудительно линковать **статически** (в том числе и системные библиотеки);
     - `-L` — указать путь к библиотекам;
     - `-l<name>` — указать, с какой библиотекой линковаться (`lib<name>.a`).
   - В некоторых системах статическая линковка системных библиотек может быть ограничена или не рекомендована.

2. **Смешанная линковка**
   - Программа может:
     - использовать часть библиотек статически,
     - а другие — динамически.
   - Например, собственные вспомогательные библиотеки — статические, а системные (`libc`) — динамические.

3. **Оптимизации линковщика**
   - Современные линковщики могут:
     - удалять неиспользуемые функции (`--gc-sections`);
     - собирать код по принципу «одна функция — один объектный модуль», чтобы не тянуть лишнее.

---

## 11. Пример логики работы ОС с программой, собранной со статической библиотекой

1. На этапе сборки:
   - линковщик объединяет:
     - объектные файлы программы;
     - нужные объектные файлы из статических библиотек;
   - формирует единый исполняемый файл (ELF, PE и т.д.).

2. При запуске:
   - ОС загружает **один** файл программы в память;
   - никакой отдельной подгрузки статической библиотеки не требуется;
   - динамический линковщик практически не участвует (если нет динамических зависимостей).

3. В памяти:
   - код программы и код статически подключённых библиотек — просто разные участки одного и того же образа.

---

## 12. Краткий итог (конспект для запоминания)

1. **Статическая библиотека** — это архив объектных модулей (`.a`, `.lib`), код которых **встраивается** в исполняемый файл на этапе линковки.
2. Программа, собранная со статической библиотекой:
   - содержит в себе весь необходимый код;
   - не требует наличия этой библиотеки в системе при запуске.
3. При линковке:
   - линковщик выбирает только те модули из библиотеки, которые действительно нужны;
   - выполняет разрешение символов и формирует единый бинарник.
4. **Плюсы** статических библиотек:
   - самодостаточные исполняемые файлы;
   - отсутствие проблем с версиями библиотек;
   - простота развёртывания;
   - полезны во встраиваемых и аварийных системах.
5. **Минусы**:
   - больший размер исполняемых файлов;
   - повышенное суммарное потребление RAM;
   - сложность обновления (нужно пересобирать программы);
   - не очень удобно в больших системах с множеством приложений.
6. В операционных системах статические библиотеки занимают свою нишу там, где нужна:
   - надёжность и независимость от окружения;
   - минимальный набор внешних зависимостей;
   - простота запуска в любых условиях.

Этот конспект можно использовать как готовый ответ на экзаменационный билет по теме  
**«Статически разделяемые библиотеки»**.
