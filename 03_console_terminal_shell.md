# Понятие текстовой консоли, эмулятор терминала и командная оболочка

## Текстовая консоль (tty)
- Исторически терминал был отдельным устройством (телетайп/видеотерминал) с последовательным интерфейсом (UART, RS‑232), печатавшим все, что присылает хост.
- В Unix терминал абстрагирован как символьное устройство TTY; процесс видит его как обычный файл, но драйвер TTY добавляет поведение терминала (линия редактирования, эхо, сигналы).
- В Linux виртуальные текстовые консоли представлены устройствами `/dev/tty1`…`/dev/ttyN`; переключение между ними обычно комбинациями `Ctrl+Alt+Fn`.
- Каждая виртуальная консоль имеет свой драйверный буфер экрана: ядро само рисует текст через VGA/DRM/KMS, независимо от X11/Wayland.
- На серверных и встраиваемых системах часто используют серийные консоли (`/dev/ttyS0`, `/dev/ttyAMA0`, `/dev/ttyUSB0`), где терминал — это другая машина, подключённая кабелем.
- Консоль обычно привязана к процессу `getty`, который показывает приглашение логина и после успешной аутентификации запускает login‑shell пользователя.
- Управление режимами ввода/вывода реализовано через интерфейс `termios`: canonical (строковый) режим, raw‑режим, локальное эхо, обработка специальных клавиш.
- В canonical‑режиме драйвер TTY буферизует ввод до нажатия Enter, поддерживает backspace и редактирование строки; в raw‑режиме байты идут напрямую программе (типично для `vim`, `less`, `ssh`, игр).
- Специальные управляющие клавиши (Ctrl+C, Ctrl+Z, Ctrl+D и др.) обрабатываются на уровне драйвера TTY и преобразуются в сигналы или специальные события.

## Эмулятор терминала
- Эмулятор терминала — это обычное пользовательское приложение в графической среде, которое эмулирует поведение аппаратного терминала.
- Примеры: `xterm`, `gnome-terminal`, `konsole`, `alacritty`, `kitty`, `wezterm` и множество других.
- Эмулятор разбирает escape‑последовательности (VT100/VT220/ANSI), управляющие курсором, цветом, атрибутами (bold, underline), очисткой экрана и т.д.
- Для приложений эмулятор выглядит как «настоящий» терминал, потому что использует механизм псевдотерминалов (PTY).
- В Linux пара PTY — это мастер и слейв: master `/dev/ptmx` + конкретный slave `/dev/pts/N`; эмулятор открывает master, shell и программы — slave.
- Когда shell пишет на стандартный вывод, байты попадают в slave‑часть PTY, ядро перенаправляет их на master, а эмулятор читает и рисует текст.
- Переменная окружения `TERM` говорит приложению, какой тип терминала эмулируется (`xterm-256color`, `screen`, `tmux`, `linux` и т.п.).
- Для описания возможностей конкретного терминала используется база `terminfo`; утилиты `tput`, `infocmp` и библиотеки `ncurses` читают её и формируют правильные escape‑последовательности.
- Эмулятор добавляет удобства: копирование/вставка, вкладки, сплит‑панели, кастомные шрифты и схемы цвета, при этом протокол взаимодействия (escape‑коды) остаётся классическим.

## Командная оболочка (shell)
- Командная оболочка — это интерактивный интерпретатор команд и язык скриптов (Bash, Zsh, fish, dash, ash, PowerShell и т.д.).
- Shell читает ввод (TTL/PTY), разбирает строку на токены, выполняет подстановки и только потом запускает программы через системные вызовы `fork`/`execve`.
- Основные виды подстановок: переменные (`$VAR`), командная подстановка (`$(cmd)` и устаревший `` `cmd` ``), арифметика (`$((expr))`), glob‑шаблоны (`*`, `?`, `[a-z]`).
- Shell реализует конвейеры (`|`): вывод одной команды подключается к вводу следующей через pipe (`pipe(2)`), образуя граф процессов.
- Перенаправления (`>`, `>>`, `<`, `2>`, `&>`) меняют, к чему привязаны стандартные файловые дескрипторы (stdin/stdout/stderr) запускаемой команды.
- Оболочка умеет выполнять команды последовательно (`;`), условно (`&&` / `||`), в под‑шелле (`( ... )`) и в текущем шелле (`source`, `.`).
- В скриптах доступны условия (`if`, `case`), циклы (`for`, `while`, `until`), функции, массивы, механизмы обработки ошибок (`set -e`, `trap`).
- В интерактивном режиме shell обычно использует линейный редактор (readline, zle) для истории, автодополнения, горячих клавиш (Emacs/Vim‑стиль).

## Файловые дескрипторы и стандартные потоки
- В Unix всё — файлы: обычные файлы, каталоги, сокеты, каналы, устройства, TTY — всё представлено через файловые дескрипторы (FD).
- Файловый дескриптор — это маленькое целое число в процессе, указывающее на запись в таблице открытых файлов (offset, флаги, указатель на объект ядра).
- По умолчанию каждый процесс запускается с тремя стандартными дескрипторами:
  - `0` — стандартный ввод (stdin),
  - `1` — стандартный вывод (stdout),
  - `2` — стандартный поток ошибок (stderr).
- В интерактивной сессии все три FD обычно указывают на одно и то же TTY/PTY‑устройство (`/dev/pts/N`), поэтому ввод/вывод идёт в один и тот же терминал.
- Разделение stdout и stderr удобно, чтобы перенаправлять «нормальный» вывод и ошибки отдельно.
- Простейшие примеры перенаправлений:
  - `ls >out.txt` — stdout (`1`) направлен в файл, stderr остаётся на терминале.
  - `ls 2>err.txt` — stderr (`2`) направлен в файл, stdout остаётся на терминале.
  - `ls >all.txt 2>&1` — сначала stdout в файл, затем stderr перенаправлен в то же место, что stdout (оба потока в `all.txt`).
  - `command <input.txt` — stdin (`0`) читается из файла вместо терминала.
- В пайпе `cmd1 | cmd2` shell создаёт анонимный канал: stdout `cmd1` привязан к записи в pipe, stdin `cmd2` — к чтению из pipe, а stderr по умолчанию остаётся на терминале.
- Терминал в ядре отличает управляющие символы (например, Ctrl+C), формирует сигналы и передаёт их не одному процессу, а целой группе процессов (process group), связанной с этим TTY.

## Управление заданиями (job control)
- Job control — механизм, с помощью которого интерактивный shell управляет несколькими процессами, связанными с одним TTY.
- Shell группирует процессы, запущенные одной командой/конвейером, в группу процессов и помечает одну из групп как foreground, остальные — как background.
- Foreground‑группа получает ввод с терминала и сигналы управления (Ctrl+C, Ctrl+Z и др.); background‑группы ввод с терминала получать не могут.
- Почти все современные интерактивные оболочки (bash, zsh, fish) поддерживают job control; в простых non‑interactive скриптах он обычно отключён.

### Запуск в фоне: `&`, `jobs`
- Если к команде добавить `&` в конце, shell запускает её в фоне (background) и сразу возвращает приглашение:
  ```bash
  $ sleep 1000 &
  [1] 12345
  ```
- Вывод `[1] 12345` означает: номер задания в shell (`[1]`) и PID лидера группы процессов (`12345`).
- Посмотреть текущее состояние заданий можно командой `jobs`:
  ```bash
  $ jobs
  [1]+  Running    sleep 1000 &
  ```
- Команда `jobs -l` дополнительно показывает PID, а `jobs -p` может вывести только PID для использования в других командах.
- Такое «огрублённое» управление часто достаточно: поставил долгую задачу в фон, работаешь дальше, периодически проверяешь `jobs`.

### Приостановка и перевод в фон: `Ctrl+Z`, `bg`
- Частый сценарий: вы запустили программу в foreground и понимаете, что хотите временно от неё «отлипнуть», не завершая её.
- Нажатие `Ctrl+Z` отправляет процессу (точнее, всей foreground‑группе) сигнал `SIGTSTP`, по которому большинство программ останавливаются (состояние `T` в `ps`).
  ```bash
  $ vim bigfile
  # нажимаем Ctrl+Z
  [1]+  Stopped    vim bigfile
  ```
- Shell видит, что foreground‑job остановлено, и возвращает приглашение, а само задание получает номер (если это было новое задание).
- После этого можно:
  - возобновить его в фоне: `bg %1` (или просто `bg`, если это последнее задание),
  - либо вернуть в foreground: `fg %1`.
- Пример:
  ```bash
  $ sleep 1000
  # Ctrl+Z
  [1]+  Stopped    sleep 1000
  $ bg %1
  [1]+  sleep 1000 &
  $ jobs
  [1]+  Running    sleep 1000 &
  ```
- Обратите внимание: пока задание в фоне, оно продолжает выполняться, но stdin у него — всё тот же TTY, и попытка чтения приведёт к сигналу `SIGTTIN` и остановке процесса.

### Возврат в foreground: `fg`
- Команда `fg` переводит выбранное задание из фона в foreground и передаёт ему управление терминалом.
- Если аргумент не указан, `fg` берёт «последнее» задание (обычно отмеченное знаком `+` в выводе `jobs`).
  ```bash
  $ jobs
  [1]-  Running    sleep 1000 &
  [2]+  Stopped    vim bigfile
  $ fg %2
  vim bigfile
  ```
- После вызова `fg` shell блокируется, ожидая завершения (или очередной остановки) процесса: командная строка вернётся только когда foreground‑job снова отдаст управление.

### Удалённые и «откреплённые» задания: `disown`, `nohup`
- Если закрыть терминал (разорвать TTY), процессам обычно прилетит `SIGHUP`, и они завершатся.
- Есть несколько способов «открепить» задания от текущего терминала:
  - `nohup cmd &` — запустить команду так, чтобы она игнорировала `SIGHUP` и перенаправила вывод в `nohup.out`, потом закрыть терминал;
  - в bash/zsh можно использовать `disown` на уже запущенном задании:
    ```bash
    $ long-command &
    [1] 23456
    $ disown %1
    ```
    После `disown` shell перестаёт отслеживать это задание; оно продолжит работать, даже если вы закроете терминал (если корректно настроены сигналы).
- Для долгоживущих фоновых задач часто логичнее использовать системные механизмы (`systemd` unit, `cron`, `at`), а не навешивать ответственность на интерактивный shell.

### Job control и пайпы
- В конвейере `cmd1 | cmd2 | cmd3` все три команды попадают в одну группу процессов и рассматриваются shell как одно задание.
- При нажатии Ctrl+C сигнал `SIGINT` отправляется всей группе: и `cmd1`, и `cmd2`, и `cmd3` должны либо завершиться, либо корректно его обработать.
- Аналогично, Ctrl+Z (`SIGTSTP`) останавливает весь конвейер; затем можно возобновить его через `bg`/`fg` как единое целое.
- Пример:
  ```bash
  $ yes | head
  # Ctrl+Z
  [1]+  Stopped    yes | head
  $ bg %1
  [1]+  yes | head &
  ```
- При этом каждый процесс конвейера имеет свой PID, но общий PGID (process group ID), который совпадает с PID лидера группы.

## Взаимодействие оболочки и TTY
- При запуске login‑shell становится лидером сеанса и владельцем управляющего терминала (controlling terminal).
- Shell использует системные вызовы `tcgetattr`/`tcsetattr` (через `termios`), чтобы переключать режимы работы TTY в зависимости от задач (обычный ввод vs `vim`/`less`).
- Когда пользователь набирает команду, shell читает байты со stdin (TTY) через стандартные функции чтения (`read`, `fgets`, readline‑обёртки).
- При запуске программ shell наследует им свои stdin/stdout/stderr; если не делалось перенаправление, эти дескрипторы всё равно указывают на тот же TTY.
- Управляющие клавиши обрабатываются драйвером TTY: так, Ctrl+C вызывает `SIGINT` для foreground‑группы процессов, а Ctrl+Z — `SIGTSTP`, что важно для job control.
- Программы вроде `ssh`, `screen`, `tmux` внутри создают свои PTY и запускают в них но…201 lines truncated…`bash`).
- Чтобы понять, какие процессы к какому TTY относятся и в каких они группах, удобно смотреть `ps -o pid,ppid,pgid,sid,tty,stat,cmd`.

## Термины
- TTY — Teletype/terminal: абстракция текстового терминала в Unix (реального или виртуального).
- PTY — Pseudo‑TTY: пара устройств master/slave для эмуляции терминала в пользовательском пространстве.
- Login shell — первая оболочка после аутентификации пользователя (через `getty`/`ssh`); инициализирует сессию, читает `~/.profile`, `~/.zprofile` и т.п.
- Non‑login shell — оболочка, запущенная внутри текущей сессии (например, новая вкладка терминала); обычно читает `~/.bashrc`/`~/.zshrc`.
- Foreground job — задание, которому сейчас принадлежит управляющий терминал и которое получает ввод/сигналы от клавиатуры.
- Background job — задание, работающее без владения терминалом; не может читать с TTY (иначе получит `SIGTTIN`), но может писать в него.
- Process group (PGID) — группа процессов, объединённых для совместного управления сигналами (foreground/background относительно TTY).
- Session — набор process groups, связанных общим управляющим терминалом; лидером сессии обычно является login‑shell.
- Terminal driver — часть ядра, реализующая семантику TTY: буферизацию, редактирование, сигналы, escape‑последовательности и т.д.

