
# 1. Что такое VFS и зачем он нужен

VFS (Virtual File System, виртуальная файловая система) — это абстрактный слой в ядре ОС, который:
 1. Предоставляет единый интерфейс к файловой системе для процессов (через системные вызовы: open, read, write, stat, …).
 2. Скрывает различия между конкретными реализациями файловых систем (ext4, XFS, NTFS, NFS, tmpfs, procfs, …).
 3. Позволяет подключать разные файловые системы одновременно и работать с ними одинаково, как будто они — части единой иерархии /.
```
                     +-------------------+
                     |   VFS interface   |
                     +---------+---------+
                               |
        -------------------------------------------------
        |                               |               |
        v                               v               v
+-------------------+        +-------------------+   +-------------------------+
| local file system |        | local file system |   | remote file system      |
|      type 1       |        |      type 2       |   |        type 1           |
+---------+---------+        +---------+---------+   +------------+------------+
          |                            |                          |
          v                            v                          v
     +---------+                 +---------+                 +-----------+
     |  disk   |                 |  disk   |                 |  network  |
     +---------+                 +---------+                 +-----------+
```

VFS — это абстракция для работы с файлами, задающая модель объектов и операций, а конкретные драйверы файловых систем реализуют эту модель для своих форматов на диске или в сети.

# 2. Основные абстракции VFS: объекты и дескрипторы

2.1. Файловая система как объект

На самом верхнем уровне:
 • Файловая система — это множество файлов и каталогов, расположенных на некотором носителе (или в памяти/сети), с общими правилами хранения, именования и прав.
 • В VFS это обычно описывается объектом уровня “superblock”:
 • общая информация о ФС: тип (ext4, NFS, …), размер, флаги монтирования;
 • указатели на таблицу операций этой файловой системы (как монтировать, как читать корневой каталог и т.д.).

“VFS хранит абстракцию файловой системы как структуру с набором операций, которые конкретная реализация обязана поддерживать.”


2.2. Inode / vnode — абстракция “файлового объекта”

Вторая ключевая сущность — сам файл как объект.
 • В классической Unix-модели у файла есть:
 • тип (обычный, каталог, симлинк, устройство),
 • права доступа,
 • владелец,
 • размер,
 • временные метки (ctime, mtime, atime),
 • указатели на блоки данных на диске.
 • Это всё описывается inode (index node).

На уровне VFS:
 • VFS вводит унифицированную структуру “vnode” / “inode VFS”, которая:
 • представляет любой объект ФС (файл, каталог, спецфайл);
 • содержит абстрактные поля (права, тип, размер),
 • и набор указателей на функции (операции над этим объектом: read, write, lookup, create, unlink и т.п.).

VFS видит не “конкретный блок на диске”, а абстрактный файловый объект с определённым набором допустимых операций. Как именно это отображается в реальные блоки — знает драйвер конкретной ФС.

2.3. Directory entry (dentry) — связь “имя → объект”

Очень важное понятие: файл в файловой системе — это не только данные, но и имя, лежащее в каком-то каталоге.

VFS обычно разделяет:
 1. Файловый объект (inode/vnode) — сущность, хранящая метаданные и данные;
 2. Запись каталога (directory entry, dentry) — пара (имя, ссылка на inode).

Зачем это нужно:
 • Один и тот же inode может иметь несколько имён (hard link → несколько dentry указывают на один inode).
 • VFS кэширует dentry → ускоряет разбор путей (/home/user/project/file.txt), чтобы не читать каталог с диска каждый раз.

VFS вводит отдельную абстракцию для именования: каталоги содержат записи “имя → файловый объект”. Это позволяет отделить “что за объект” от “под каким именем на него ссылаются”.

2.4. Открытый файл: объект “open file” и дескриптор

С точки зрения процесса:
 • Он видит просто целое число — file descriptor: 0, 1, 2, 3 и т.д.
 • Но в ядре за этим стоит объект “открытого файла”.

Внутри VFS обычно есть:
 • Таблица файлов процесса: массив/таблица, где:
 • индекс = file descriptor;
 • значение = указатель на объект “open file”.
 • Объект “open file” (file object / file handle) хранит:
 • указатель на VFS-inode,
 • текущий offset (смещение при чтении/записи),
 • флаги: O_RDONLY, O_APPEND, O_NONBLOCK и т.д.,
 • указатель на набор операций (file_operations: read, write, llseek, mmap…).

2.6. Из заметок: inode/dentry и ссылки

- inode хранит ключевые метаданные: тип объекта, права, владельца, временные метки, счётчик ссылок и указатели на данные.
- dentry связывает имя с inode; именно поэтому жёсткие ссылки — это несколько dentry, указывающих на один и тот же inode.
- `unlink()` удаляет запись каталога, но сам inode освобождается только когда счётчик ссылок и количество открытых дескрипторов становятся нулём.
- `ln` без `-s` создаёт ещё одну ссылку на существующий inode, а `ln -s` формирует новый симлинк со своим inode и путём назначения.

Дескриптор — это индекс в таблице открытых файлов процесса, а не “сам файл”.
VFS хранит состояние открытия файла (позиция, режим) в отдельной структуре, разделяемой между процессами при fork() и dup().

2.5. Mount table — таблица монтирования

VFS воспринимает всю систему как единое дерево с корнем /.

Но фактически:
 • разные её поддеревья могут принадлежать разным файловым системам (ext4 на диске, tmpfs в памяти, NFS по сети, procfs — виртуальная).
 • При монтировании ОС заносит запись в таблицу монтирования:
 • на какой директории (/mnt/data) “подвешена” какая ФС;
 • какой тип ФС;
 • какие флаги монтирования.

VFS при разборе пути /mnt/data/file:
 1. Дойдя до mnt, смотрит: есть ли здесь точка монтирования;
 2. Если да — переключается на другой superblock (другую ФС) и продолжает поиск уже в её корне.

⸻

3. Модель “объекты + операции”

Классический канон:
Каждая абстракция задаётся (1) типом объекта, (2) набором операций над ним.

В VFS есть несколько типов объектов:
 • файловая система (superblock),
 • inode/vnode,
 • запись каталога (dentry),
 • открытый файл (file),
 • точка монтирования.

И для каждого есть набор методов, которые должна реализовать конкретная файловая система:
 • Операции над файловой системой (superblock)
 • монтирование, размонтирование;
 • чтение корневого каталога;
 • синхронизация на диск.
 • Операции над inode/vnode
 • создание/удаление файлов;
 • создание линков;
 • поиск записи в каталоге (lookup);
 • изменение прав, атрибутов.
 • Операции над открытым файлом (file)
 • read, write;
 • llseek (изменение позиции);
 • mmap;
 • fsync;
 • ioctl и др.

Смысл:

VFS определяет интерфейс (набор абстрактных операций).
Конкретная ФС обязана реализовать эти операции в соответствии с этим интерфейсом, чтобы ядро могло управлять ею прозрачно.

⸻

4. Разбор пути (pathname resolution) как ключевой сценарий

Один из центральных механизмов VFS — разбор имени файла:
Допустим, процесс вызывает:

open("/home/rafael/docs/file.txt", O_RDONLY);

VFS делает примерно следующее:
 1. Начать с корневого inode файловой системы /.
 2. Взять первую компоненту пути home:
 • найти в каталоге / dentry с именем home;
 • получить inode каталога /home.
 3. В каталоге /home найти user → inode /home/user.
 4. Затем docs → inode каталога /home/user/docs.
 5. Затем file.txt → получить inode файла.
 6. Создать объект “open file” с указателем на найденный inode, установить offset=0, флаги.
 7. Вернуть процессу file descriptor.

Во время этого процесса VFS:
 • пользуется кешами inode и dentry, чтобы не читать каждый раз всё с диска;
 • учитывает точки монтирования, если встречает их по пути;
 • вызывая операции у конкретной ФС, не заботится о формате данных на диске.

⸻

5. Роль VFS в многотипной и распределённой ФС

VFS позволяет ядру работать так, как будто существует единая иерархическая файловая система, даже если на самом деле:
 • часть файлов — на локальном диске,
 • часть — в сети (NFS),
 • часть — в памяти (tmpfs),
 • часть — чисто виртуальные (procfs).

То есть:
 • VFS даёт единообразие интерфейса для процессов (все используют open/read/write).
 • Конкретные ФС реализуют этот интерфейс с учётом своих особенностей (кэширование, сетевые протоколы, форматы блоков).

⸻

6. Связь VFS с буферным кешем и page cache

 • Буферный кеш / page cache — это слой, который кеширует страницы данных файлов.
 • VFS взаимодействует с этим кешем, чтобы:
 • при чтении/записи не обращаться каждый раз к диску;
 • объединять физически разные ФС под одним механизмом кэширования.
Важно:
 • VFS отвечает за абстракцию объектов и операции,
 • а подсистема кэширования — за эффективность доступа.

⸻

7. Главные “основные понятия VFS” в одном списке

Чтобы было, что выписать в билет:
 1. VFS (Virtual File System)
 • абстрактный слой в ядре, унифицирующий доступ к разным файловым системам.
 2. Файловая система (superblock)
 • объект, описывающий отдельную ФС: тип, размер, состояние, корневой каталог, набор операций.
 3. Inode / vnode
 • абстрактный файловый объект: метаданные + таблица операций.
 4. Directory entry (dentry)
 • запись каталога: имя → ссылка на inode; используется для кэширования разбора путей.
 5. Открытый файл (file object)
 • состояние открытого файла: указатель на inode, позиция, флаги; связан с дескриптором в таблице процесса.
 6. File descriptor
 • целое число в пространстве процесса → индекс в его таблице открытых файлов.
 7. Mount table
 • таблица монтирования: какие файловые системы “подвешены” на каких директориях.
 8. Интерфейс операций VFS
 • набор функций (операций) для superblock, inode, file и др., которые реализуются драйверами ФС.
 9. Разбор пути (pathname resolution)
 • процесс пошагового просмотра компонентов пути, поиска dentry/inode и учёта точек монтирования.
