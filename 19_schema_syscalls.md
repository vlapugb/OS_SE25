
# Механизм системных вызовов в операционных системах

## 1. Зачем нужны системные вызовы

Операционная система разделяет выполнение кода на два основных режима:

- **Пользовательский режим (user mode)**  
  - работает обычное приложение;
  - доступ ограничен: нельзя напрямую обращаться к устройствам, таблицам страниц, прерываниям и т. д.
- **Привилегированный режим (kernel mode, режим ядра)**  
  - работает ядро ОС;
  - полный доступ к оборудованию и внутренним структурам данных.

Приложению всё-таки нужно:
- читать и писать файлы;
- создавать процессы и потоки;
- работать с сетью;
- управлять памятью и др.

Поэтому вводится **механизм системных вызовов** — контролируемый, безопасный переход из пользовательского режима в режим ядра.

---

## 2. Общая идея системного вызова

**Системный вызов (system call, syscall)** — это операция, с помощью которой процесс в пользовательском режиме просит ядро выполнить определённую функцию от своего имени.

Пример логики:
1. Программа вызывает стандартную функцию библиотеки (например, `read`, `write`, `open` в C).
2. Эта функция:
   - подготавливает аргументы в соответствии с соглашением вызова (ABI),
   - помечает номер нужного системного вызова,
   - выполняет специальную инструкцию процессора (например, `syscall`, `sysenter`, `int 0x80` и т. п.).
3. Процессор:
   - переключается в привилегированный режим,
   - передаёт управление кода ядра по заранее настроенному входу.
4. Ядро:
   - читает номер системного вызова,
   - забирает аргументы,
   - выполняет нужную функцию (например, чтение из файла),
   - возвращает результат (значение или код ошибки).
5. Процессор возвращается в пользовательский режим и продолжает выполнение программы.

---

## 3. Уровни абстракции: библиотека и ядро

Обычно различают:

1. **Библиотечный уровень (glibc, MSVCRT, и др.)**
   - программист вызывает обычную функцию, например:
     ```c
     ssize_t n = read(fd, buf, size);
     ```
   - на этом уровне:
     - может быть буферизация,
     - дополнительные проверки,
     - совместимость разных версий интерфейса;
     - собственно *низкоуровневый системный вызов* часто скрыт.
2. **Уровень системного вызова ядра**
   - реализуется в ядре;
   - имеет фиксированный **номер** (идентификатор системного вызова);
   - принимает параметры в регистрах / стеке по соглашению ABI;
   - возвращает результат (или -1 и устанавливает `errno`).

---

## 4. Таблица системных вызовов

Внутри ядра есть **таблица системных вызовов** — массив указателей на функции ядра:

```text
syscall_table[0]  -> sys_read
syscall_table[1]  -> sys_write
syscall_table[2]  -> sys_open
...
```

При выполнении системного вызова:
1. Ядро узнаёт номер `n` (например, в регистре).
2. Проверяет, что `n` в допустимых пределах.
3. Выполняет `syscall_table[n](arg1, arg2, ...)`.

---

## 5. Шаги выполнения системного вызова (обобщённо)

**1. Подготовка параметров в пользовательском режиме**

- Программа вызывает библиотечную функцию (например, `read`).
- Библиотека:
  - размещает аргументы (дескрипторы, указатели, длины) в нужных регистрах / на стеке;
  - помещает номер системного вызова в определённый регистр;
  - вызывает специальную инструкцию перехода в ядро.

**2. Переход в режим ядра**

- Процессор:
  - сохраняет часть контекста (адрес возврата, флаги и т. п.);
  - переключает привилегии (user → kernel);
  - перескакивает по адресу, указанному в таблице обработчиков (IDT, MSR и т. д.).

**3. Диспетчеризация в ядре**

- Ядро начинает выполнение с общей «обёртки» (entry point системного вызова).
- Проверяется номер системного вызова.
- Выполняется переход к нужной функции ядра.

**4. Выполнение кода ядра**

- Ядро выполняет операцию — например:
  - проверяет права доступа процесса;
  - читает/записывает данные в файловую систему;
  - планирует/создаёт новый процесс;
  - настраивает таблицу страниц и т. д.
- Использует внутренние структуры (таблицы процессов, таблицы файловых дескрипторов и др.).

**5. Подготовка результата**

- Возвращаемое значение помещается в регистр (например, количество прочитанных байт или код ошибки).
- При ошибке часто возвращается -1, а подробный код сохраняется в `errno`.

**6. Возврат в пользовательский режим**

- Ядро вызывает специальную инструкцию возврата из системного вызова.
- Процессор:
  - восстанавливает сохранённый контекст,
  - переключается обратно в пользовательский режим,
  - продолжает выполнение программы с инструкции после системного вызова.

---

## 6. Пример: системный вызов `read` (логика на псевдокоде)

Пользовательский код:

```c
char buf[100];
ssize_t n = read(fd, buf, 100);
```

Примерная последовательность:

1. Библиотечная функция `read`:
   - кладёт номер системного вызова `SYS_read` в регистр;
   - передаёт `fd`, `buf`, `100` в нужные регистры;
   - выполняет `syscall` (или другой механизм).
2. В ядре:
   - проверяется, что `fd` — корректный файловый дескриптор процесса;
   - смотрится тип объекта: файл, сокет, труба;
   - вызывается соответствующая реализация чтения;
   - данные копируются из ядра в пользовательский буфер (через проверенные указатели).
3. Результат (количество прочитанных байт либо -1) возвращается через регистр.
4. Библиотека при необходимости обновляет `errno` и возвращает значение пользователю.

---

## 7. Механизмы перехода в ядро (на уровне архитектуры)

На разных архитектурах и даже в пределах одной архитектуры (x86, x86_64) существует несколько способов сделать системный вызов.

### 7.1. С программным прерыванием (trap, software interrupt)

Пример: инструкция вида `int 0x80` на x86.

- Преимущества:
  - простота реализации;
  - исторически первые реализации системных вызовов.
- Недостатки:
  - относительно медленный механизм (много логики обработки прерывания).

### 7.2. Специальные инструкции: `syscall`, `sysenter` и др.

- Предоставляют **быстрый переход** между user mode и kernel mode.
- Поддерживаются современными процессорами.
- Обычно используются в сочетании с:
  - регистрами, хранящими адрес точки входа ядра,
  - заданным протоколом передачи аргументов.

---

## 8. Защита и проверки в системных вызовах

Ядро должно защитить себя и систему от ошибок и злонамеренного поведения:

- Проверка **доступности адресов**:
  - указатели из пользовательского режима не должны указывать на память ядра;
  - адреса проверяются и/или используются безопасные функции копирования (`copy_from_user`, `copy_to_user`).
- Проверка **прав доступа**:
  - файловые разрешения, UID/GID, ACL;
  - разрешения на операции с сокетами, устройствами и т. п.
- Проверка **ограничений**:
  - максимальные размеры буферов;
  - лимиты на количество открытых файлов, процессов и т. д.

Если проверки не пройдены — возвращается ошибка (например, `EFAULT`, `EPERM`, `EACCES` и др.).

---

## 9. Контекстный переключатель и системные вызовы

Системный вызов может быть:

- **быстрым**:
  - например, `getpid()` просто читает значение из таблицы процесса;
  - ядро почти не блокируется, не переключает задачи.

- **блокирующим**:
  - чтение из файла, ожидание данных по сети, `sleep`, ожидание дочернего процесса;
  - ядро может **усыпить** текущий поток и передать процессор другому,
    то есть в рамках системного вызова происходит **планирование и переключение контекста**.

Таким образом:
- системный вызов часто = потенциальная точка переключения потока (thread) или процесса (process).

---

## 10. Системные вызовы и файловые дескрипторы

Файловые дескрипторы — основной интерфейс к объектам ввода-вывода.

Примеры системных вызовов, работающих с файловыми дескрипторами:

- `open(path, flags, mode)` → возвращает целое число **fd**;
- `read(fd, buf, count)` → читает данные;
- `write(fd, buf, count)` → пишет данные;
- `close(fd)` → закрывает дескриптор;
- `dup`, `dup2`, `fcntl` и другие.

Здесь:
- системный вызов обеспечивает **переход в ядро и выполнение операции**,
- файловый дескриптор — это **идентификатор ресурса**, с которым ядро будет работать.

---

## 11. Обработка ошибок и `errno`

Большинство системных вызовов возвращает:

- **некоторое значение ≥ 0** при успехе (например, количество байт);
- **-1 при ошибке**, и при этом устанавливается глобальная переменная `errno`
  (в C/Posix-модели).

Типичные коды ошибок:
- `EINTR` — системный вызов прерван сигналом;
- `EAGAIN` — ресурс временно недоступен, нужно повторить;
- `EBADF` — неверный файловый дескриптор;
- `EACCES` — нет прав доступа и т. д.

---

## 12. Итоговая схема механизма системных вызовов

Кратко:

1. Пользовательский код вызывает библиотечную функцию.
2. Библиотека:
   - готовит аргументы,
   - помещает номер системного вызова,
   - выполняет особую инструкцию перехода в ядро.
3. Процессор переключается в режим ядра и передаёт управление точке входа системных вызовов.
4. Ядро:
   - определяет номер системного вызова,
   - проверяет аргументы и права,
   - выполняет требуемую операцию с ресурсами,
   - подготавливает результат (или код ошибки).
5. Процессор возвращается в пользовательский режим.
6. Библиотека возвращает значение вызывающей программе и, при необходимости, выставляет `errno`.

Таким образом, системные вызовы являются **основным, строго контролируемым шлюзом** между пользовательским кодом и ресурсами, которыми управляет ядро операционной системы.