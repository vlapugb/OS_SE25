# Filesystem Hierarchy Standard и концепция merged /usr

## Основная идея FHS
- FHS (Filesystem Hierarchy Standard) описывает, какие каталоги обязаны быть в Unix‑подобной системе и что в них должно лежать.
- Цель: предсказуемые пути для системных компонентов, чтобы скрипты, демоны и админские утилиты не «угадывали» расположение файлов.
- Важный принцип: разделение неизменяемой части системы (`/usr`, иногда read‑only) и изменяемых данных (`/etc`, `/var`, `/home`).
- Для разработчика Linux FHS — это «карта местности», по которой легко понять, куда устанавливать своё ПО и откуда его забирать.

## Корень `/` и базовые каталоги
- `/` — корень файловой системы; минимально должен содержать то, что нужно для:
  - монтирования остальных файловых систем (`/usr`, `/home`, `/var`),
  - запуска init/systemd и recovery‑инструментов,
  - диагностики при сильно повреждённой системе.
- `/boot` — ядро (`vmlinuz`), initramfs (`initrd.img`), конфиги загрузчика (GRUB, systemd‑boot) и иногда microcode‑обновления.
- `/dev` — устройства (device nodes), управляются `udev`/`systemd-udevd`; здесь лежат:
  - блочные устройства (`/dev/sda`, `/dev/nvme0n1`),
  - символьные (`/dev/tty*`, `/dev/random`),
  - псевдо‑устройства (`/dev/null`, `/dev/zero`, `/dev/full`).
- `/proc` — псевдо‑файловая система для информации о процессах и ядре (PID‑каталоги `/proc/<pid>`, `/proc/cpuinfo`, `/proc/meminfo`, `/proc/sys`).
- `/sys` — sysfs: представление ядра и драйверов в виде древовидных директорий (устройства, шины, драйверы, настройки энергосбережения и т.д.).
- `/tmp` — временные файлы для пользовательских программ, обычно очищается при перезагрузке; часто монтируется как tmpfs.
- `/run` — ранние временные файлы и сокеты, доступные до монтирования «обычных» ФС; systemd хранит здесь PID‑файлы, сокеты, runtime‑состояние.
- `/mnt` — точка монтирования временных/ад‑hoc файловых систем (админом руками).
- `/media` — автоматически монтируемые устройства (USB‑флешки, CD/DVD) через desktop‑stack.
- `/srv` — данные сервисов (www, ftp, vcs), если дистрибутив придерживается FHS буквально.

## Исполняемые файлы: `/bin`, `/sbin`, `/usr/bin`, `/usr/sbin`
  - `/usr/lib*` — библиотеки, модули, плагины,
  - `/usr/include` — заголовки для разработки,
  - `/usr/share` — архитектурно‑независимые данные: документация, man‑страницы, локализации, иконки, шаблоны.
- `/usr/local` — «локальные» установки, не управляемые дистрибутивом:
  - `/usr/local/bin`, `/usr/local/sbin`, `/usr/local/lib`, `/usr/l
- Исторически `/bin` и `/sbin` содержали «жизненно важные» утилиты для ранней загрузки и обслуживания системы, доступные даже без смонтированного `/usr`.
- `/bin`:
  - базовые команды для обычного пользователя и скриптов: `sh`, `bash` (иногда), `cp`, `mv`, `rm`, `ln`, `cat`, `echo`, `ls`, `mkdir`, `rmdir`, `ps` (часто), `kill`, `chmod`, `chown`, `sync`.
  - в usr‑merge системах `/bin` — симлинк на `/usr/bin`.
- `/sbin`:
  - админские утилиты, связанные с системой и сетью: `mount`, `umount`, `fsck*`, `ip`, `ifconfig` (legacy), `route`, `sysctl`, `shutdown`, `reboot`.
  - в usr‑merge системах `/sbin` — симлинк на `/usr/sbin`.
- `/usr/bin`:
  - основная масса пользовательских программ: `gcc`, `make`, `git`, `python`, `perl`, `tar`, `grep`, `awk`, `sed`, `find`, `ssh`, `curl`, `less`, `vim`, `nano` и многое другое.
  - здесь же CLI‑клиенты многих графических приложений.
- `/usr/sbin`:
  - демоны и системные утилиты: `sshd`, `nginx`, `cron`/`crond`, `apache2`, `systemd-*`, сетевые службы (`dhclient`, `named`), инструменты администрирования (`useradd`, `groupadd`).
- Ключевой момент для разработчика: когда вы устанавливаете своё CLI‑приложение через пакет, оно почти всегда должно идти в `/usr/bin` (или `/usr/sbin`, если строго root‑only).

## Библиотеки: `/lib`, `/lib64`, `/usr/lib*`
- `/lib` и `/lib64` — системные библиотеки, критичные для запуска программ в `/bin` и `/sbin`, плюс модули ядра (обычно `/lib/modules`).
- Примеры содержимого `/lib*`:
  - динамический линкер (`ld-linux-x86-64.so.2` и аналоги),
  - `libc.so`, `libpthread.so`, `libm.so`, `ld-linux*`, минимальные крипто‑ и I/O‑библиотеки.
- В современных дистрибутивах для многоархитектурности используются подкаталоги:
  - `/lib/x86_64-linux-gnu`, `/lib/i386-linux-gnu`, `/usr/lib/x86_64-linux-gnu` и т.п.
- `/usr/lib` и `/usr/lib64`:
  - основная масса разделяемых библиотек (`.so`), плагинов и модулей (например, модули `systemd`, плагины `gstreamer`, расширения `python`, модули `apache`).
  - здесь же часто лежат вспомогательные бинарники, привязанные к конкретным библиотекам (`/usr/lib/git-core/*`, `systemd`‑units библиотек и т.д.).
- Модули ядра (`.ko`) обычно лежат в `/lib/modules/$(uname -r)`, а в `/usr/lib/modules` — только в специфичных дистрибутивах.

## Конфигурация: `/etc`
- `/etc` — конфигурация конкретного хоста: всё, что описывает «как эта машина настроена».
- Ключевые файлы, которые должен знать любой опытный разработчик:
  - `/etc/passwd` — список пользователей, UID/GID, shell, home‑директория.
  - `/etc/shadow` — захэшированные пароли (обычно root‑only).
  - `/etc/group` — группы и их участники.
  - `/etc/fstab` — таблица файловых систем и опции монтирования.
  - `/etc/hosts`, `/etc/hostname`, `/etc/resolv.conf` — базовая сеть (имя хоста и резолв DNS).
  - `/etc/ssh/sshd_config`, `/etc/ssh/ssh_config` — настройки SSH‑сервера/клиента.
  - `/etc/sudoers`, `/etc/sudoers.d/*` — правила `sudo`.
  - `/etc/systemd/system` — юниты, созданные администратором или пакетами (overrides и drop‑ins).
  - `/etc/sysctl.conf`, `/etc/sysctl.d/*.conf` — настройки параметров ядра (`sysctl`).
  - `/etc/modules-load.d/*.conf` — список модулей ядра для автозагрузки.
- Конфиги пакетов обычно лежат в `/etc/<имя_приложения>/` (`/etc/nginx`, `/etc/apache2`, `/etc/network/interfaces`, `/etc/NetworkManager/`, `/etc/docker/` и т.д.).
- Для разработчика важно: не писать в `/etc` из приложений напрямую; конфиги либо устанавливаются пакетами, либо генерируются отдельными утилитами/инсталляторами.

## Данные и состояние: `/var`
- `/var` хранит изменяемые данные, состояние сервисов и кеши:
  - `/var/log` — журналы: `syslog`, `kern.log`, `auth.log`, логи приложений (`/var/log/nginx`, `/var/log/mysql`).
  - `/var/lib` — «рабочие базы» демонов: базы данных (`/var/lib/mysql`, `/var/lib/postgresql`), состояние `dpkg`/`rpm`, данные `docker`, `kubernetes` и т.д.
  - `/var/run` (часто симлинк на `/run`) — PID‑файлы, сокеты, runtime‑метаданные.
  - `/var/cache` — кэши (`/var/cache/apt/archives`, кэш шрифтов, кэш веб‑серверов).
  - `/var/spool` — очереди заданий (почта, печать, cron).
  - `/var/tmp` — временные файлы, живущие дольше одного перезапуска (в отличие от `/tmp`).
- При проектировании сервисов важно понимать, что:
  - конфигурация — в `/etc`,
  - логика работы и бинарники — в `/usr`,
  - состояние и данные сервиса — в `/var/lib/<service>` и `/var/log/<service>`.

## Домашние директории: `/home`, `/root`
- `/home` — домашние каталоги обычных пользователей (`/home/alice`, `/home/bob`):
  - пользовательские конфиги (`.bashrc`, `.config`, `.ssh`),
  - проекты, данные, пользовательские виртуальные окружения (`venv`, `node_modules`, `go/pkg`).
- `/root` — домашний каталог суперпользователя:
  - отдельные SSH‑ключи, root‑специфичные конфиги (`.bashrc`, `.profile`),
  - традиционно не хостится на сетевых ФС по соображениям безопасности/доступности.
- Для приложений действует правило: пользовательские настройки и данные по умолчанию должны лежать в `$HOME` (XDG‑директории), а не в системных каталогах.

## `/usr` и `/usr/local`
- `/usr` — основная «системная» иерархия для ПО, обслуживаемого пакетным менеджером:
  - `/usr/bin`, `/usr/sbin` — исполняемые файлы,
  - `/usr/lib*` — библиотеки, модули, плагины,
  - `/usr/include` — заголовки для разработки,
  - `/usr/share` — архитектурно‑независимые данные: документация, man‑страницы, локализации, иконки, шаблоны.
- `/usr/local` — «локальные» установки, не управляемые дистрибутивом:
  - `/usr/local/bin`, `/usr/local/sbin`, `/usr/local/lib`, `/usr/local/include`, `/usr/local/share`.
  - сюда логично устанавливать ПО из исходников (`make install`), если не хочется мешать пакетам дистрибутива.
- Для опытного разработчика важно помнить: пакетный менеджер дистрибутива обычно не трогает `/usr/local/*`, поэтому столкновения минимальны.

## `/opt` и стороннее ПО
- `/opt` — место для больших сторонних пакетов, особенно бинарных дистрибутивов, не вписывающихся в стандартную /usr‑иерархию.
- Примеры: `/opt/google/chrome`, `/opt/intellij`, `/opt/android-sdk`.
- Обычно внутри `/opt/<vendor>/<product>` есть свои `bin`, `lib`, `share`, а в `/usr/bin` создаётся симлинк или маленький wrapper‑скрипт.

## Merged /usr (usr-merge)
- Концепция usr‑merge: «реальные» файлы живут только в `/usr/*`, а `/bin`, `/sbin`, `/lib*` — это симлинки в `/usr`.
- Типичная схема:
  - `/bin -> usr/bin`,
  - `/sbin -> usr/sbin`,
  - `/lib -> usr/lib`,
  - `/lib64 -> usr/lib64` (на 64‑битных системах).
- Мотивация usr‑merge:
  - единое место для бинарников и библиотек, меньше дублирования и особых случаев,
  - упрощение chroot/контейнеров: достаточно смонтировать `/usr` и базовые /dev,/proc,/sys,
  - better integration с systemd и initramfs: ранний userspace уже может содержать полный `/usr`,
  - уменьшение расхождений между десктопами и контейнерами, однообразные пути для инструментов разработки.
- Примеры дистрибутивов с usr‑merge: Debian (начиная с Bullseye/Bookworm по умолчанию), Ubuntu, Fedora, Arch, многие производные.

## Практические последствия usr‑merge
- Скрипты и программы не должны полагаться на различие между `/bin` и `/usr/bin`, `/sbin` и `/usr/sbin`: все пути эквивалентны через симлинки.
- Правильный подход для разработчика:
  - вызывать программы по имени, доверяя `PATH`,
  - избегать жёстко прошитых путей, если нет строгой необходимости.
- При сборке контейнеров и минимальных образов:
  - стоит учитывать, что `/bin` может быть симлинком; при копировании файлов нужно сохранить симлинки, а не разворачивать их в отдельные каталоги,
  - достаточно скопировать `/usr/bin`/`/usr/lib*`, а `/bin`/`/lib` «приедут» через симлинки.
- initramfs в usr‑merge‑мире обязан смонтировать `/usr` ещё до запуска PID 1 (systemd или другого init), иначе базовые бинарники могут оказаться недоступны.
- При резервном копировании лучше использовать режим, который учитывает симлинки (иначе можно получить искусственное дублирование `/bin` и `/usr/bin`).

## Потенциальные проблемы
- Старые chroot‑окружения или нестандартные embedded‑сборки без usr‑merge:
  - пакеты, которые предполагают наличие симлинков `/bin -> usr/bin`, могут устанавливать файлы «не туда», ломая запуск.
- Скрипты с жёстко прописанными путями могут вести себя неожиданно:
  - при наличии `/usr/sbin` в PATH, но отсутствии `/sbin`, либо наоборот, если админ изменил PATH.
- Неправильные инструменты бэкапа могут продублировать содержимое `/usr` через симлинки в `/bin`/`/lib`.
- При переносе старых систем на новые дистрибутивы иногда проще сделать чистую установку с usr‑merge, чем мигрировать in‑place.

## Источники
- FHS 3.0 (Filesystem Hierarchy Standard).
- Debian usrmerge initiative, Fedora UsrMove.
- Документация systemd по раннему монтированию `/usr`.
