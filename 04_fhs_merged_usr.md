# Экзаменационный билет: Filesystem Hierarchy Standard и концепция *merged /usr*

## 1. Filesystem Hierarchy Standard (FHS): общее представление

**Filesystem Hierarchy Standard (FHS)** — это стандарт, описывающий:
- **структуру каталогов** в Unix‑подобных ОС (в первую очередь в Linux);
- **назначение** основных директорий;
- какие типы файлов и данных должны где храниться.

Цели FHS:
1. Обеспечить **предсказуемую структуру** файловой системы.
2. Упростить переносимость программ и пакетов между дистрибутивами.
3. Сделать систему понятной администратору: где что искать (конфиги, логи, бинарники).

FHS определяет:
- какие каталоги должны быть в корне (`/`),
- что должно храниться в `/bin`, `/etc`, `/home`, `/usr`, `/var` и т.д.

---

## 2. Основные каталоги по FHS и их назначение

Ниже — краткий обзор ключевых директорий согласно FHS (упрощённо, для экзамена).

### 2.1. Корневой каталог `/`

Содержит:
- минимальный набор каталогов, необходимых для **загрузки системы** и её работы до монтирования других файловых систем;
- точки монтирования других разделов.

Типичные подкаталоги:
- `/bin` — базовые утилиты;
- `/sbin` — системные утилиты администратора;
- `/etc` — конфигурация;
- `/lib`, `/lib64` — базовые библиотеки;
- `/dev`, `/proc`, `/sys` — псевдофайловые системы;
- `/boot` — ядро и загрузчик;
- `/root` — домашний каталог суперпользователя;
- `/run`, `/tmp`, `/mnt`, `/media` и др.

### 2.2. Каталог `/bin`

- **Essential user commands** — важнейшие программы общего назначения.
- Должны быть доступны **на ранних этапах загрузки** и при работе в однопользовательском режиме (single user mode).
- Примеры: `sh`, `bash`, `cat`, `ls`, `cp`, `mv`, `rm`, `mkdir`, `rmdir`, `echo`, `ps`, `kill`, `mount`, `umount` (в классической схеме).

### 2.3. Каталог `/sbin`

- **System binaries** — системные команды администратора.
- Обычно требуют прав `root`.
- Используются при:
  - загрузке системы;
  - настройке и ремонте системы.
- Примеры: `ifconfig` (старый), `ip`, `fsck`, `reboot`, `shutdown`, `mkfs.*` и т.п.

### 2.4. Каталог `/etc`

- **Конфигурационные файлы системы** (обычно текстовые).
- Конфиги демонов, служб, системных настроек.
- Примеры: `/etc/fstab`, `/etc/passwd`, `/etc/hostname`, конфиги сетевых сервисов и т.п.
- По идее **не содержит бинарников** или больших данных.

### 2.5. Каталог `/lib` и `/lib64`

- Основные **разделяемые библиотеки** (shared libraries), необходимые для:
  - работы программ из `/bin` и `/sbin`,
  - запуска системы.
- Также могут храниться модули ядра: `/lib/modules/...` (в некоторых системах).

### 2.6. Каталог `/usr`

Исторически:
- `/usr` (user system resources) — это:
  - программы и данные **общего назначения**;
  - которые **не нужны для самого раннего этапа загрузки**;
  - которые могут находиться на отдельном разделе, монтируемом позже.

Типичное содержимое:
- `/usr/bin` — основная масса пользовательских программ;
- `/usr/sbin` — системные утилиты, не критичные для ранней загрузки;
- `/usr/lib`, `/usr/lib64` — библиотеки для программ из `/usr/bin` и `/usr/sbin`;
- `/usr/share` — архитектурно‑независимые данные (локализации, документация, иконки);
- `/usr/include` — заголовочные файлы для разработки;
- `/usr/local` — место для локально установленных программ (вручную, без пакетного менеджера).

### 2.7. Каталог `/var`

- **Variable data** — меняющиеся данные:
  - логи (`/var/log`);
  - очереди почты (`/var/spool`);
  - кэш (`/var/cache`);
  - PID‑файлы, временные данные служб.

### 2.8. Другие важные каталоги

- `/home` — домашние каталоги пользователей;
- `/tmp` — временные файлы (обычно очищаются);
- `/dev` — устройства (device files);
- `/proc`, `/sys` — виртуальные файловые системы с информацией о системе и ядре;
- `/media`, `/mnt` — точки монтирования внешних носителей и временных файловых систем.

---

## 3. Исторический контекст разделения `/` и `/usr`

Изначально:
- Диски были **маленькие**, дорогие, медленные.
- Систему разбивали на:
  - небольшой корневой раздел `/` с минимальным набором инструментов;
  - отдельный раздел `/usr` с основным софтом.

Причины:
1. Корневой раздел мог быть на **быстром/надёжном устройстве**, доступном с самого начала.
2. `/usr` мог располагаться:
   - на другом физическом диске;
   - на **сетевом ресурсе** (NFS) и разделяться между несколькими машинами.

Поэтому:
- всё, что требуется **до** монтирования `/usr`, — в `/bin`, `/sbin`, `/lib`;
- всё остальное — в `/usr/bin`, `/usr/sbin`, `/usr/lib`, и т.д.

---

## 4. Концепция *merged /usr*: что это такое

**Merged /usr** (иногда: *usr-merge*) — это схема организации файловой системы, при которой:
- каталоги в корне (`/bin`, `/sbin`, `/lib`, `/lib64`) становятся **только ссылками** (обычно символьными);
- **реальные** файлы (бинарники, библиотеки) физически лежат под `/usr/...`.

Пример:
- `/bin` → символическая ссылка на `/usr/bin`;
- `/sbin` → символическая ссылка на `/usr/sbin`;
- `/lib` → символическая ссылка на `/usr/lib`;
- `/lib64` → символическая ссылка на `/usr/lib64` (на 64‑битных системах).

Идея:
- фактически **все программы и библиотеки** находятся в дереве `/usr`;
- корень `/` хранит только:
  - точки монтирования,
  - конфигурацию,
  - псевдофайловые системы,
  - минимальные служебные директории,
  - и **ссылки** на соответствующие подкаталоги внутри `/usr`.

---

## 5. Мотивация и причины перехода к merged /usr

Почему возникла концепция *merged /usr*?

1. **Исторические ограничения ушли**
   - Сейчас:
     - диски больше;
     - отдельный `/usr` на другом физическом носителе или по сети — редкость.
   - Большинство систем монтируют корень `/` и `/usr` **одной файловой системой**.

2. **Упрощение структуры**
   - Вместо дублирования дерево `/bin`, `/sbin`, `/lib` и аналогичных под `/usr`:
     - всё кладётся в `/usr/...`;
     - в корне остаются только ссылки.
   - Это упрощает:
     - упаковку и установку пакетов;
     - поиск файлов;
     - поддержку системы.

3. **Единообразие путей**
   - Многие программы и сборочные системы могут работать с едиными путями `/usr/bin`, `/usr/lib` и т.п.
   - Нет необходимости разруливать: что в `/bin`, а что в `/usr/bin`, если по сути это одинаковый уровень «важности».

4. **Совместимость с initramfs и ранней загрузкой**
   - На практике:
     - при загрузке часто используется `initramfs`, который сам уже содержит нужные инструменты;
     - после перехода к «настоящему» root fs `/usr` уже смонтирован.
   - Не нужна жёсткая зависимость: «нельзя использовать `/usr` до монтирования…».

5. **Упрощение контейнеров и образов**
   - При сборке контейнеров и образов удобно иметь:
     - компактное, логичное дерево `/usr`;
     - минимальный корень `/` как «обвязку».

---

## 6. Как это выглядит на практике

При *merged /usr*:
- папки верхнего уровня — **симлинки**, например:

```bash
/bin   -> usr/bin
/sbin  -> usr/sbin
/lib   -> usr/lib
/lib64 -> usr/lib64
```

- Бинарные файлы реально находятся в:
  - `/usr/bin`;
  - `/usr/sbin`;
- Библиотеки — в:
  - `/usr/lib`, `/usr/lib64`.

Это всё ещё **совместимо с FHS**, т.к.:
- FHS описывает **логическую структуру** и назначение каталогов;
- технически допускается, что некоторые каталоги могут быть символическими ссылками.

Для программ и пользователей:
- старые пути продолжают работать:
  - `/bin/ls` → фактически `/usr/bin/ls`;
  - `/sbin/fsck` → `/usr/sbin/fsck`;
- но с точки зрения разметки файла на диске вся логика сосредоточена в `/usr`.

---

## 7. Плюсы и минусы merged /usr

### 7.1. Преимущества

1. **Упрощение структуры системы**
   - Все бинарники и библиотеки — в одном дереве `/usr`.
   - Легче поддерживать, проще писать правила для пакетных менеджеров и скриптов.

2. **Единая политика размещения**
   - Нет путаницы: «что считать *основной* утилитой, чтобы положить в `/bin`».
   - Всё, что поставляет дистрибутив, идёт в `/usr/...`.

3. **Упрощение пакетных менеджеров**
   - Меньше файловых сценариев, меньше различий между пакетами.
   - Возможность делать снапшоты и монтировать `/usr` отдельно (например, read‑only).

4. **Оптимизация для современных реалий**
   - Большинство систем уже не завязаны на отдельный `/usr` как сетевой ресурс.
   - Реальный сценарий: один раздел для всего `/` + возможно отдельные `/home`, `/var` и т.п.

### 7.2. Недостатки и критика

1. **Разрыв с классической моделью**
   - Старые администраторы и документация исходят из идеи:
     - «/bin и /sbin — это минимальный набор для спасения системы»;
   - при *merged /usr* это логически смещается в область `/usr`.

2. **Дополнительная сложность при очень специфичных сценариях**
   - Если действительно нужен отдельный `/usr`, монтируемый поздно или по сети:
     - нужно аккуратно настроить начальную фазу загрузки (initramfs);
     - часть логики переходит в initramfs.

3. **Зависимость от initramfs**
   - Система в большей степени опирается на initramfs и ранний пользовательский простор.
   - Без initramfs поддержка сложных сценариев разделения `/` и `/usr` становится трудной или невозможной.

---

## 8. Связь FHS и merged /usr

Важно понимать:
- **FHS** задаёт **семантику** каталогов: какое назначение у `/bin`, `/usr/bin` и т.п.
- **Merged /usr** — это **конкретная реализация** этой семантики:
  - мы говорим: «файлы, которые *логически* относятся к `/bin`, физически лежат в `/usr/bin`, но доступны через симлинк».

Таким образом:
- FHS и *merged /usr* **не противоречат** друг другу;
- Merged /usr — это способ:
  - упростить структуру;
  - адаптировать классическую схему к современным реалиям (общая файловая система, initramfs, контейнеры и т.д.).

---

## 9. Типичный сценарий загрузки в системе с merged /usr

1. **Загрузка ядра и initramfs**
   - Загрузчик (GRUB и др.) поднимает ядро и initramfs.
   - Внутри initramfs есть свой минимальный набор утилит.

2. **Монтирование корневой файловой системы**
   - initramfs монтирует основной root `/`.
   - В этот момент `/usr` обычно **уже часть** корневой файловой системы (один и тот же раздел) или монтируется сразу же.

3. **Переход на основной root (`switch_root`)**
   - После переключения:
     - `/bin`, `/sbin`, `/lib*` уже являются симлинками на `/usr/...`;
     - все базовые утилиты доступны.

4. **Дальнейшая инициализация**
   - Запускается `systemd`, `init` или другой менеджер;
   - Загружаются службы, файловые системы, монтируются `/var`, `/home` и т.д.

**Ключевой момент:** система не полагается на наличие отдельных *физических* файлов в `/bin` и `/sbin` до монтирования `/usr` — всё живёт в `/usr`, а начальные потребности отрабатываются внутри initramfs.

---

## 10. Итоговый конспект (что запомнить для экзамена)

1. **FHS (Filesystem Hierarchy Standard)** — стандарт, описывающий:
   - структуру каталогов в Unix‑подобных системах;
   - назначение директорий `/`, `/bin`, `/sbin`, `/etc`, `/lib`, `/usr`, `/var`, `/home` и др.

2. Исторически:
   - `/` — минимальная система для загрузки и восстановления;
   - `/usr` — остальной софт, часто на отдельном разделе/сервере.

3. **Каталоги по FHS (кратко)**:
   - `/bin` — важные пользовательские утилиты;
   - `/sbin` — важные системные утилиты администратора;
   - `/etc` — конфиги;
   - `/lib`, `/lib64` — библиотеки для `/bin` и `/sbin`;
   - `/usr/...` — основная масса программ и библиотек;
   - `/var` — логи, кэш, очереди;
   - `/home` — данные пользователей.

4. **Merged /usr** — схема, при которой:
   - `/bin`, `/sbin`, `/lib*` → симлинки на соответствующие каталоги внутри `/usr`;
   - все реальные бинарники и библиотеки хранятся в `/usr/bin`, `/usr/sbin`, `/usr/lib` и т.п.

5. Зачем нужен merged /usr:
   - упрощение структуры и обслуживания системы;
   - уход от исторических ограничений (отдельный `/usr`);
   - удобство для контейнеров, initramfs, современных дистрибутивов.

6. Совместимость:
   - FHS задаёт **логические роли** каталогов;
   - merged /usr реализует их через симлинки, не нарушая смысл.

Этот конспект можно использовать как готовый развернутый ответ на экзаменационный билет  
**«Filesystem Hierarchy Standard и концепция merged /usr»**.
