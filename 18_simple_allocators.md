
# Простейшие и более сложные аллокаторы памяти. Понятие файлового дескриптора

## 1. Задачи управления памятью

Аллокатор памяти — это компонент (библиотека или часть ОС), который:
- **выделяет** участки памяти по запросу программы;
- **освобождает** их;
- ведёт **учёт свободных и занятых областей**;
- старается минимизировать:
  - накладные расходы (по времени и памяти),
  - **фрагментацию** (дробление памяти на множество маленьких дырок),
  - количество системных вызовов к ОС (`sbrk`, `mmap`, `VirtualAlloc` и др.).

Обычно различают:
- **низкоуровневые аллокаторы** (на уровне ОС и рантайма: реализация `malloc/new`);
- **высокоуровневые аллокаторы** (специализированные: арены, пулами, GC и т. д., поверх `malloc` или напрямую поверх ОС).

---

## 2. Простейшие аллокаторы памяти

### 2.1. Линейный (bump / arena / region allocator)

Один из самых простых вариантов.

#### Идея
- Есть **непрерывный буфер памяти**.
- Ведём один указатель `ptr`, который указывает на «конец» уже выделенной области.
- При запросе `alloc(size)`:
  1. округляем `size` до выравнивания;
  2. проверяем, влезает ли в буфер;
  3. возвращаем текущий `ptr` и двигаем его вперёд на `size`.

```c
struct Arena {
    unsigned char* base;
    size_t capacity;
    size_t offset; // смещение от base
};

void* arena_alloc(struct Arena* a, size_t size) {
    size = (size + 7) & ~((size_t)7); // выравнивание до 8 байт
    if (a->offset + size > a->capacity) {
        return NULL; // нет места
    }
    void* ptr = a->base + a->offset;
    a->offset += size;
    return ptr;
}

void arena_reset(struct Arena* a) {
    a->offset = 0; // освобождаем всё сразу
}
```

#### Плюсы
- Очень **быстрый** (по сути, одна проверка и увеличение счётчика).
- Нет фрагментации внутри арены.
- Отлично подходит для временных структур, которые живут одинаковое время (например, один кадр игры, один HTTP-запрос).

#### Минусы
- Нет **индивидуального освобождения** блоков — только «сбросить всё сразу».
- Нужно самому планировать жизненный цикл арены.

---

### 2.2. Стековый аллокатор (stack allocator)

Похож на линейный, но позволяет «откатывать» память **последним вошёл — первым вышел (LIFO)**.

#### Идея
- Есть буфер и «вершина стека».
- `alloc` двигает вершину вверх.
- Освобождение возможно только в **обратном порядке**:
  - либо явно хранить маркеры (метки),
  - либо освобождать последнюю выдачу.

```c
struct StackAlloc {
    unsigned char* base;
    size_t capacity;
    size_t top;
};

size_t stack_mark(struct StackAlloc* s) {
    return s->top;
}

void stack_release(struct StackAlloc* s, size_t mark) {
    s->top = mark; // откат к предыдущему состоянию
}
```

#### Применение
- Парсеры, интерпретаторы, вычисление выражений, где удобно работать с временными объектами в строгом LIFO-порядке.

---

### 2.3. Аллокатор со списком свободных блоков (free-list)

Это уже похоже на упрощённый `malloc`.

#### Идея
- Память разбита на блоки.
- Есть **список свободных блоков**.
- При выделении ищется подходящий свободный блок:
  - `first-fit` — первый подходящего размера,
  - `best-fit` — самый маленький, который подходит,
  - `worst-fit` — самый большой и т. д.
- Если блок больше, чем нужно, его можно **разделить**.
- При освобождении:
  - блок добавляется в список свободных,
  - по возможности **сливается с соседями**, чтобы уменьшить фрагментацию.

```c
struct BlockHeader {
    size_t size;
    bool   free;
    struct BlockHeader* next;
};
```

---

## 3. Более сложные аллокаторы

### 3.1. Segregated free lists (раздельные списки свободных блоков)

#### Идея
- Вместо одного списка свободных блоков используются **несколько списков по диапазонам размеров**:
  - 8 байт, 16 байт, 32 байта, ..., отдельный список для больших блоков.
- Выделение:
  - выбирается список, соответствующий размеру,
  - берётся первый блок из этого списка.
- Часто используется в реальных реализациях `malloc` (glibc, jemalloc, tcmalloc).

#### Плюсы
- Быстрая выдача блока нужного размера.
- Меньше фрагментации, если грамотно настроить классы размеров.

---

### 3.2. Buddy allocator (аллокатор напарников / «бади»)

#### Идея
- Всё пространство памяти — блок размера `2^k`.
- При запросе меньшего блока:
  - большой блок делится пополам: получаются два «бадди» (напарника),
  - это повторяется, пока размер не станет достаточно мал.
- При освобождении:
  - проверяется, свободен ли «брат-близнец» (бадди);
  - если да — блоки сливаются обратно в блок большего размера.

#### Плюсы
- Быстрое выделение и освобождение (много операций простыми битовыми вычислениями).
- Структура памяти упорядочена, удобно для ядра ОС, страниц и фреймов.

#### Минусы
- Внутренняя фрагментация — всегда размер блока — степень двойки.

---

### 3.3. Slab allocator (аллокатор слэбов)

Часто используется в ядрах ОС (например, Linux).

#### Идея
- Для каждого **типа объектов фиксированного размера** создаётся «slab cache».
- Каждому кэшу соответствует набор страниц памяти, разделённых на объекты одинакового размера.
- Не нужно хранить размер каждого объекта (он известен типу кэша).

#### Плюсы
- Очень быстрые `alloc/free` для часто создаваемых объектов (inode, дескрипторы, структуры ядра).
- Мало фрагментации для фиксированных размеров.

---

### 3.4. Аллокатор общего назначения (`malloc`, `new`)

Типичная реализация стандартного аллокатора:
- комбинирует **segregated lists**, **bump-аллокаторы** для маленьких объектов,
- использует `mmap`/`sbrk` для запроса больших кусков памяти у ОС,
- заботится о **потокобезопасности** (локальные арены на поток, шардирование и т. п.).

---

## 4. Управление памятью «не простейшего уровня»: сборщики мусора

В языках с автоматическим управлением памятью (Java, C#, многие скриптовые языки) память выделяется высокоуровневым аллокатором, а освободить её должен **сборщик мусора (GC)**.

### 4.1. Примеры стратегий GC
- **Mark-and-sweep** (пометить и удалить):
  1. От корней (стек, глобальные переменные) помечаются достижимые объекты.
  2. Проход «sweep» освобождает все непомеченные блоки.
  - Плюс: не требует компактного представления, работает на расшаренной памяти.
  - Минус: без дополнительной компакции оставляет фрагментацию.
- **Copying GC**:
  - Память делится на две полуобласти; живые объекты копируются в новую область, указатели обновляются.
  - Компактирует кучу и улучшает локальность, но требует запас памяти.
  - Хорош для молодых объектов, которые либо умирают быстро, либо копируются дёшево.
- **Generational GC** (поколенческий):
  - Делит кучу на молодое и старое поколения; большинство объектов умирает молодыми, поэтому молодое поколение собирается часто и быстро (minor GC).
  - Долгоживущие объекты «продвигаются» в старшее поколение, которое собирается реже (major GC).
  - Требуются **write barriers** и таблицы карт (card table), чтобы отслеживать ссылки из старого поколения в молодое.
- **Reference counting**:
  - Каждый объект хранит счётчик ссылок; при достижении нуля освобождается немедленно.
  - Прост в реализации, но плохо работает с циклами ссылок и добавляет накладные расходы на инкременты/декременты.

### 4.2. Паузы, компакция и барьеры
- Любой GC создаёт паузы — время, когда приложение остановлено для поиска мусора. Чтобы их уменьшить, используют **инкрементальные** (пошаговые) и **конкурентные** (параллельные с приложением) алгоритмы.
- Инкрементальные/конкурентные коллекторы используют инварианты (например, три-цветную маркировку) и **write barriers**, чтобы приложение не разрушало картину достижимости во время работы сборщика.
- **Компактация** уменьшает фрагментацию и улучшает локальность кэша, но требует перестройки указателей или косвенной адресации (handle table).

### 4.3. Связь с ОС
Даже при наличии GC «внизу» используются `malloc` или прямые вызовы ОС (`mmap`, `VirtualAlloc`) для резервирования и коммита страниц. GC управляет логической кучей, но отдаёт/возвращает целые страницы ОС, чтобы не удерживать лишнюю память у процесса.

---

## 5. Связь аллокаторов и ОС

Традиционно:
- Программа вызывает `malloc/new`.
- Реализация `malloc`:
  - либо использует уже полученные от ОС «арены»,
  - либо запрашивает новые страницы у ОС (`sbrk`, `mmap`).
- ОС управляет **физической памятью и страничной подкачкой**, а пользовательские аллокаторы — логической раскладкой внутри виртуального адресного пространства процесса.

---

## 6. Понятие файлового дескриптора

### 6.1. Определение

**Файловый дескриптор (file descriptor, FD)** — это целочисленный идентификатор, который ОС выдаёт процессу для обращения к открытому объекту ввода-вывода:

- обычный файл,
- каталог,
- сокет,
- канал (`pipe`),
- устройство и т. д.

Файловый дескриптор — это **индекс в таблице открытых файлов процесса**.

---

### 6.2. Стандартные файловые дескрипторы

| FD | Имя    | Назначение             |
|----|--------|------------------------|
| 0  | stdin  | стандартный ввод       |
| 1  | stdout | стандартный вывод      |
| 2  | stderr | стандартный вывод ошибок |

---

### 6.3. Как создаётся файловый дескриптор

1. Программа вызывает системный вызов:
   - `open`, `creat` — для файлов;
   - `socket` — для создания сетевого сокета;
   - `pipe`, `dup`, `accept` и др.
2. Ядро:
   - находит/создаёт объект файла (inode, сокет, устройство),
   - создаёт запись в **глобальной таблице открытых файлов** ядра,
   - создаёт запись в **таблице дескрипторов процесса**, которая указывает на запись ядра,
   - возвращает **целое число** — индекс в таблице процесса.

Позже это число используется в вызовах `read`, `write`, `close`, `poll`, `select`, `fcntl` и т. д.

---

### 6.4. Пример работы с файловым дескриптором (C)

```c
#include <fcntl.h>   // open
#include <unistd.h>  // read, write, close
#include <stdio.h>

int main() {
    int fd = open("file.txt", O_RDONLY);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    char buf[128];
    ssize_t n = read(fd, buf, sizeof(buf));
    if (n < 0) {
        perror("read");
        close(fd);
        return 1;
    }

    write(1, buf, n); // пишем в stdout (fd = 1)
    close(fd);        // закрываем дескриптор
    return 0;
}
```

---

### 6.5. Дублирование файловых дескрипторов

Иногда нужно, чтобы несколько дескрипторов указывали на **один и тот же объект файла** и разделяли одно файловое смещение.

Для этого используются:
- `dup(oldfd)` — возвращает новый дескриптор с тем же объектом;
- `dup2(oldfd, newfd)` — делает `newfd` копией `oldfd`.

Пример: перенаправление вывода в файл:

```c
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("out.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) return 1;

    dup2(fd, 1); // теперь stdout (fd=1) указывает на out.txt
    close(fd);

    write(1, "Hello\n", 6); // на самом деле пишет в файл
    return 0;
}
```

---

### 6.6. Закрытие файлового дескриптора

`close(fd)` делает следующее:
- уменьшает **счётчик ссылок** на объект файла;
- если счётчик стал 0, ядро:
  - освобождает структуру, описывающую файл,
  - при необходимости записывает данные на диск,
  - освобождает связанные ресурсы (буферы, сокеты и др.).

Важно **закрывать все дескрипторы**, иначе:
- возможна утечка ресурсов (исчерпание FD);
- данные могут не быть записаны полностью (если не произошло закрытия/сброса).

---

### 6.7. Файловые дескрипторы и потоки

В POSIX-процессе:
- **все потоки разделяют одну таблицу файловых дескрипторов**;
- один и тот же `int fd` виден во всех потоках.

Следствия:
- Параллельный `read/write` по одному FD может привести к перемешанным данным.
- Нужно использовать **средства синхронизации** (мьютексы) при работе нескольких потоков с одним FD.
- Закрытие `fd` в одном потоке делает его недействительным для всех остальных.

---

### 6.8. Наследование и флаги дескрипторов

-   При `fork` дочерний процесс наследует копии дескрипторов, указывающих
    на те же открытые файлы. Если этого не нужно, устанавливают флаг
    `FD_CLOEXEC`/`O_CLOEXEC`, чтобы дескриптор закрылся на `exec`.
-   Поведение ввода-вывода контролируется флагами `O_NONBLOCK`,
    `O_APPEND`, `O_SYNC` (настраиваются через `open` или `fcntl`).
-   Метаданные дескриптора (позиция в файле, режим неблокирующего I/O)
    разделяются всеми копиями, поэтому изменение флагов через `fcntl`
    воздействует на все дубли (`dup/dup2/fork`).

---

## 7. Связь файловых дескрипторов и управления памятью

- Аллокатор (`malloc/new`) управляет **виртуальной памятью** процесса.
- Файловые дескрипторы описывают **ресурсы ввода-вывода**.
- Но между ними есть связь:
  - `mmap` может «отобразить» файл (по FD) в адресное пространство процесса, чтобы работать с ним как с обычной памятью.
  - буферизация ввода-вывода в библиотеке (`FILE*`, `std::fstream`) использует **кучу** для буферов, но внизу всё равно лежат файловые дескрипторы.

Так, операционная система предоставляет процессы память и дескрипторы ресурсов, а прикладные аллокаторы и библиотеки поверх этого строят свои модели управления.
