# POSIX: shell

## 1. Стандарт POSIX и роль shell

[SHELL](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html) - интерпретатор языка команд и язык скриптования.
POSIX не устраняет разнообразие оболочек, но стандартизирует их поведение. Если оболочка совместима с POSIX, мы можем написать команду и быть уверены, что она выполнится так, как ожидается. Bash и другие классические оболочки хорошо справляются с интерфейсом и скриптованием, тогда как Fish больше фокусируется на удобстве интерфейса.

Для командной оболочки (shell) POSIX определяет:
- базовый синтаксис командной строки и скриптов;
- обязательный набор встроенных команд;
- поведение конвейеров, перенаправлений, подстановок;
- формат переменных, аргументов, статусов завершения.

**Shell** — это:
- командный интерпретатор (взаимодействие пользователя с ОС);
- язык сценариев (скриптов);
- «клей» между утилитами ОС (ls, grep, sed, awk и др.).

POSIX‑совместимая оболочка обычно доступна как `/bin/sh`.

---

## 2. Виды оболочек и POSIX‑совместимость

Распространённые оболочки:

- **sh** — «классическая» оболочка Bourne shell, прообраз POSIX‑shell.
- **bash** — Bourne Again SHell, расширенная оболочка (много нестандартных возможностей).
- **dash** — минималистичный быстрый POSIX‑shell (часто используется как `/bin/sh` в Linux).
- **ksh** — KornShell, один из предков POSIX‑shell.
- **zsh** — мощная интерактивная оболочка, с большими расширениями.

**Важно:** POSIX определяет поведение «оболочки стандарта POSIX». Многие реальные shell добавляют расширения (arrays в bash, `[[ ]]`, `(( ))`, brace expansion и т.п.), которые **не гарантированы** в чистом POSIX‑/bin/sh.
- **Примеры работы с `echo`**
    - **Простой вывод строки в консоль**:
        
        ```bash
        echo "Hello, world"
        ```
        
    - **Вывод без переноса строки**:
        
        ```bash
        echo -n "Hello, world"
        ```
        
    - **Перенос на новую строку с использованием escape-последовательностей**:**Замечание**: Использование `e` в `echo` не стандартизировано и зависит от реализации. Например, в Bash `echo` может быть встроенной командой оболочки, а вызов `/bin/echo` будет использовать внешнюю утилиту. Это демонстрирует несовместимость ключей между встроенными и внешними командами.
        
        ```bash
        echo -e "Hello,\\nworld"
        ```
---
- **Стандартизация и инструменты проверки**
    - **Shellcheck**: Анализатор скриптов, проверяющий на соответствие POSIX и указывающий на ошибки.
        
        ```bash
        shellcheck script.sh
        ```
        
    - **Shebang**: Первая строка скрипта определяет интерпретатор. Например: Здесь `sh` — POSIX-совместимая оболочка, но она может отличаться в зависимости от системы (на Linux это часто символическая ссылка на `dash`). _шебангом кста называется именно комбинация символов #!_
        
        ```bash
        #!/bin/sh
        ```
- **Создание временных файлов**
    - Команда `mktemp` гарантирует создание уникального файла или директории:
        
        ```bash
        mktemp /tmp/tempfile.XXXXXX
        ```
- **Работа с переменными окружения**: POSIX определяет стандартные переменные, такие как `$PATH`, `$HOME`, `$USER`. Например:
    
    ```bash
    echo "Пользователь: $USER, домашний каталог: $HOME"
    ```
    
- **Командное подставление**: Используется для вставки результата команды в другую команду. В POSIX рекомендуется использовать скобки:
    
    ```bash
    result=$(ls /tmp)
    echo "Содержимое /tmp: $result"
    ```
    
- **Обработка сигналов**: POSIX поддерживает обработку сигналов через `trap`. Пример:
    
    ```bash
    trap 'echo "Прерывание!"; exit 1' INT
    while true; do sleep 1; done
    ```
### BASH, ZSH, FISH и другие

Все это sh-совместимые командные оболочки.
## 3. Жизненный цикл выполнения команды shell

1. **Чтение строки**:
   - ввод с терминала или из файла скрипта.

2. **Разбор (парсинг)**:
   - разделение на токены (слова, операторы `|`, `;`, `&&`, `||`, `>`, `<` и т.д.);
   - учёт кавычек `'...'` и `"..."`, экранирования `\`.

3. **Подстановки (expansions)**:
   В POSIX‑shell порядок примерно такой:
   1. **Tilde‑подстановка**: `~`, `~user` → домашний каталог (может быть не везде по POSIX, зависит от shell).
   2. **Параметр/переменная**: `$VAR`, `${VAR}`.
   3. **Подстановка команд**: `$(команда)` или \`команда\`.
   4. **Арифметическая подстановка**: `$((выражение))` (POSIX включает простую арифметику).
   5. **Разделение по IFS** (Internal Field Separator).
   6. **Глобbing (file name expansion)**: `*`, `?`, `[...]`.

4. **Применение перенаправлений**: `<`, `>`, `>>`, `2>`, `<<` и т.п.

5. **Запуск команды**:
   - если это **встроенная команда** (built‑in) — выполняется внутри shell‑процесса;
   - если это **внешняя программа** — создаётся новый процесс и выполняется программа (поиск через `PATH`).

6. **Получение статуса завершения**:
   - статус доступен в переменной `$?`;
   - по POSIX: **0 — успех**, ненулевое значение — ошибка (тип ошибки зависит от программы).

# **BASH (Bourne Again SHell)**

> _Он предназначен быть соответствующей (conformant) реализацией части стандарта IEEE POSIX — “Shell and Tools” из спецификации IEEE POSIX (IEEE Standard 1003.1)._

Основные возможности:

- редактирование команд прямо в командной строке;
- неограниченная история команд;
- управление заданиями (job control);
- функции оболочки и псевдонимы (alias’ы);
- индексированные массивы произвольного размера;
- целочисленная арифметика в любой системе счисления от 2 до 64.
# **ZSH (Z Shell)**

Бытует мнение, что эта оболочка **не является POSIX-совместимой**. Официального заявления нет.
> _Zsh не является POSIX-совместимой, как многие утверждают. Использование сломанной модели перенаправлений — тому доказательство. Поддержка чисел с плавающей точкой — ещё одно. Если уж учить что-то не-POSIX, то пусть это будет стандартная оболочка Linux, а не непонятный новичок, который не может определиться, чем хочет быть. Если нужна POSIX-совместимость — используйте_ _/bin/dash__, к которому на Debian-подобных системах привязан_ _/bin/sh__._

Zsh — это оболочка, ориентированная на интерактивную работу и одновременно мощный язык сценариев.
В неё включены многие полезные функции из bash, ksh и tcsh, плюс собственные уникальные возможности.
Основные особенности:

- интеллектуальное автодополнение команд, опций и аргументов;
- поддержка тем и плагинов (например, через Oh My Zsh);
- удобная работа с историей, включая поиск и синхронизацию между сессиями;
- автокоррекция команд при опечатках;
- асинхронные задачи и удобное управление фоновыми процессами;
- поддержка режимов редактирования Emacs/Vi и гибкая настройка клавиш;
- массивы и хеш-таблицы для обработки данных.
# **Fish (Friendly Interactive Shell)**

> _В отличие от других оболочек, fish не следует POSIX-стандарту, но использует примерно ту же модель._

Современная оболочка, ориентированная на удобство “из коробки”:
- автодополнение работает интуитивно, без настройки;
- удобная история команд с поиском по подстрокам;
- встроенные функции и плагины без внешних фреймворков;
- автокоррекция опечаток;
- простая настройка через веб-интерфейс;
- расширенные структуры данных (массивы, списки);
- поддержка Vi-редактирования и кастомных сочетаний клавиш;
- минимальная конфигурация для работы по умолчанию.
## 4. Типы команд в POSIX shell

### 4.1. Простая команда (simple command)

Пример:

```sh
ls -l /etc
```

Структура: **последовательность слов**, возможно с перенаправлениями.

### 4.2. Составные команды (compound commands)

- **Группы**:
  - Подшелл:

    ```sh
    ( команда1; команда2 )
    ```

    Выполняется в отдельном процессе, изменения переменных снаружи не видны.

  - Группа в текущем shell:

    ```sh
    { команда1; команда2; }
    ```

    Важно: точка с запятой **перед** `}` обязательна.

- **Условные конструкции**: `if`, `case`.
- **Циклы**: `for`, `while`, `until`.

---

## 5. Встроенные и внешние команды

### 5.1. Встроенные (built‑ins) POSIX shell

Чаще всего (список может немного отличаться у разных реализаций):

- `cd` — смена текущего каталога;
- `echo`, `printf` — вывод текста;
- `exec` — заменить текущий shell другим процессом;
- `exit` — завершить shell;
- `export` — сделать переменную переменной окружения;
- `readonly` — сделать переменную только для чтения;
- `set`, `unset` — работа с параметрами shell и переменными;
- `shift` — сдвиг позиционных параметров;
- `times` — время работы процессов;
- `type` / `command` (в зависимости от реализации) — узнать, как будет выполнена команда;
- `.` (dot) — выполнить скрипт в текущем shell (source).

Почему встроенные важны:
- работают без создания нового процесса (быстрее);
- имеют особые права (например, `cd` **должен** менять каталог текущего shell‑процесса).
### 5.2. Внешние команды

Отдельные программы, запускаемые через системный вызов `execve`:
- утилиты: `ls`, `cp`, `mv`, `rm`, `grep`, `sed`, `awk`, `find` и т.д.;
- любые исполняемые файлы в каталогах из `PATH`.
## 6. Перенаправление ввода‑вывода

Файловые дескрипторы по умолчанию:
- `0` — stdin (ввод);
- `1` — stdout (обычный вывод);
- `2` — stderr (вывод ошибок).
### 6.1. Основные формы
- Перенаправление вывода (перезаписать файл):
  ```sh
  команда > файл
  # то же, что 1>файл
  ```
- Перенаправление вывода (дописать в конец):
  ```sh
  команда >> файл
  ```
- Перенаправление ошибок:
  ```sh
  команда 2> errors.log
  команда 2>> errors.log
  ```
- Перенаправление ввода из файла:
  ```sh
  команда < input.txt
  # то же, что 0<input.txt
  ```
- Объединение stdout и stderr:
  ```sh
  команда > all.log 2>&1
  ```
  Здесь `2>&1` означает: перенаправить stderr (2) туда же, куда уже направлен stdout (1).
### 6.2. Here‑document (<<)

Позволяет подать «встроенный» текст на stdin команды:

```sh
cat <<EOF
Первая строка
Вторая строка
EOF
```

- `EOF` — произвольный маркер конца;
- ввод читается до строки, совпадающей с маркером.

### 6.3. Примеры

```sh
# запись списка файлов в файл
ls >list.txt

# разделение нормального вывода и ошибок
ls /root /etc 1>ok.log 2>err.log

# использование here‑document
wc -l <<END
one
two
three
END
```

## 7. Конвейеры и операторы управления

### 7.1. Конвейер (pipeline) `|`

Передача stdout одной команды на stdin другой:

```sh
ls /etc | grep conf
```

Особенности:
- каждый элемент конвейера — отдельный процесс (кроме возможных встроенных в некоторых реализациях);
- статус конвейера (в POSIX) обычно равен статусу **последней** команды.

### 7.2. Операторы последовательности и условий

- `;` — просто последовательное выполнение:

  ```sh
  команда1; команда2
  ```

- `&` — запуск в фоне:

  ```sh
  команда &
  ```

- `&&` — выполнить вторую команду, **если первая завершилась успешно** (код 0):

  ```sh
  make && make install
  ```

- `||` — выполнить вторую команду, **если первая завершилась с ошибкой** (код ≠ 0):

  ```sh
  make || echo "Сборка не удалась"
  ```

Комбинации:

```sh
команда1 && команда2 || команда3
```

Частый шаблон: «если команда1 прошла, то команда2, иначе команда3».

---

## 8. Переменные и окружение

### 8.1. Переменные shell

Создание и использование:

```sh
VAR=value   # без пробелов вокруг '='
echo "$VAR"
```

По умолчанию — **локальные** переменные shell (не передаются дочерним процессам).

### 8.2. Переменные окружения

Чтобы переменная передавалась запущенным программам:

```sh
export VAR=value   # задать и экспортировать
# или
VAR=value
export VAR
```

Типичные переменные окружения:

- `PATH` — список каталогов для поиска исполняемых файлов (`:`‑разделённый);
- `HOME` — домашний каталог пользователя;
- `SHELL` — путь к оболочке;
- `PWD` — текущий каталог;
- `LANG`, `LC_*` — локаль.

### 8.3. Специальные параметры shell

- `$0` — имя скрипта;
- `$1`, `$2`, … — позиционные параметры;
- `$#` — количество позиционных параметров;
- `$@` — все аргументы раздельно;
- `$*` — все аргументы как одна строка;
- `$?` — статус завершения последней команды;
- `$$` — PID текущего shell;
- `$!` — PID последнего запущенного в фоне процесса.

---

## 9. Скрипты shell: структура и запуск

### 9.1. Shebang и права

Простой скрипт:

```sh
#!/bin/sh
echo "Hello, POSIX shell"
```

Шаги:

1. Сохранить в файл, например `script.sh`.
2. Сделать исполняемым:

   ```sh
   chmod +x script.sh
   ```

3. Запустить:

   ```sh
   ./script.sh
   ```

Либо:

```sh
sh script.sh
```

(без shebang или без флага `+x`).

### 9.2. Опции shell (часто используемые)

- `set -e` — завершать скрипт при ошибке команды (код ≠ 0);
- `set -u` — ошибка при обращении к несуществующей переменной;
- `set -x` — трассировка: вывод выполняемых команд;
- `set -f` — отключить globbing (`*`, `?`).

Комбинация через `set` в скрипте:

```sh
set -eu  # «умеренно строгий» режим
```

(Замечание: некоторые опции формально не входят в POSIX, но часто поддерживаются.)

---

## 10. Условные конструкции и циклы

### 10.1. if / then / elif / else / fi

```sh
if команда; then
    # если команда вернула 0
    ...
elif другая_команда; then
    ...
else
    ...
fi
```

Часто в роли команды используется `test` или `[`:

```sh
if [ -f "$FILE" ]; then
    echo "Файл существует"
fi
```

Основные проверки `test` / `[` (POSIX):

- для файлов:
  - `-f file` — обычный файл;
  - `-d dir` — каталог;
  - `-r`, `-w`, `-x` — права чтения/записи/выполнения;
  - `-s file` — размер > 0.
- строковые:
  - `[ -z "$s" ]` — пустая строка;
  - `[ -n "$s" ]` — непустая строка;
  - `[ "$a" = "$b" ]` — равны;
  - `[ "$a" != "$b" ]` — не равны.
- числовые:
  - `-eq`, `-ne`, `-lt`, `-le`, `-gt`, `-ge`.

### 10.2. case / esac

```sh
case "$var" in
    start)
        echo "Стартуем"
        ;;
    stop)
        echo "Останавливаем"
        ;;
    *)
        echo "Неизвестная команда"
        ;;
esac
```

Удобно для разветвления по строковым шаблонам (поддерживаются glob‑шаблоны `*`, `?`, `[...]`).

### 10.3. Циклы for, while, until

**for:**

```sh
for f in *.txt; do
    echo "Файл: $f"
done
```

**while:**

```sh
while read line; do
    echo "Строка: $line"
done < file.txt
```

**until:** выполняется, пока команда возвращает **ненулевой код**:

```sh
until ping -c1 host >/dev/null 2>&1; do
    echo "Ждём, когда host станет доступен..."
    sleep 1
done
```

`break` — выйти из цикла, `continue` — перейти к следующей итерации.

---

## 11. Работа с процессами и сигналами

### 11.1. Фоновые процессы

- Запуск в фоне:

  ```sh
  команда &
  ```

- Управление (зависит от интерактивного shell):
  - `jobs` — список фоновых задач;
  - `fg` — вернуть задачу на передний план;
  - `bg` — возобновить в фоне.

### 11.2. Сигналы и trap

POSIX‑shell может перехватывать сигналы и выполнять обработчик:

```sh
trap 'echo "Ctrl+C пойман"; exit 1' INT
```

- `INT` — сигнал прерывания (обычно Ctrl+C).
- `trap 'команды' СИГНАЛЫ` — выполнить команды при получении сигнала.

Обработка завершения:

```sh
trap 'echo "Скрипт завершается"; rm -f /tmp/tmpfile' EXIT
```

`EXIT` — псевдосигнал «при выходе из shell».

---

## 12. Отличия POSIX‑shell и расширенных оболочек (bash и др.)

Важно понимать, что **не всё, что работает в bash, является POSIX**.

НЕ POSIX (или не гарантируется):

- массивы вида `arr[0]=value`;
- `[[ ... ]]` вместо `[ ... ]`;
- `(( арифметика ))` в стиле C;
- brace expansion `{1..10}`, `{a,b,c}`;
- многие опции `set` и `shopt`;
- расширенные подстановки `${var//pattern/repl}` и т.п.

Если говорят «написать POSIX‑совместимый скрипт» — значит, нужно:

- использовать только те возможности, которые определены стандартом POSIX;
- тестировать скрипт в «строгом» `/bin/sh` (часто это `dash`).

---

## 13. Краткое резюме

1. POSIX определяет *общий стандарт* для оболочки (syntax + semantics).
2. Shell — командный интерпретатор и язык скриптов.
3. Команда проходит этапы: парсинг → подстановки → перенаправления → запуск → получение статуса.
4. Есть встроенные команды (работают в самом shell) и внешние программы.
5. Перенаправления и конвейеры позволяют строить сложные цепочки обработки данных.
6. Переменные и окружение — основа настройки поведения программ.
7. POSIX shell предоставляет базовые конструкции программирования: условия, циклы, функции, обработку ошибок.
8. Расширенные оболочки (bash, zsh) добавляют много возможностей, но на экзамене по POSIX нужно опираться именно на стандартные возможности `/bin/sh`.
