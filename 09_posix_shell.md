# POSIX: shell

Стандартная оболочка переносимого интерфейса — это интерпретатор командного языка, который последовательно читает строки, выполняет лексический анализ, подстановки, управление потоками ввода-вывода и процессы, обеспечивая предсказуемое поведение сценариев на разных системах. Оболочка работает в интерактивном режиме, показывая приглашение и реагируя на сигналы терминала, и в пакетном режиме, читая сценарии из файлов или стандартного ввода. Каждая команда проходит этапы: чтение строки, разбиение на токены, выполнение подстановок параметров, арифметики и подстановок команд, расширение путей, применение кавычек для контроля разбиения на слова, затем настройка редиректов и запуск встроенной или внешней команды.

Переменные окружения передаются дочерним процессам, поэтому изменение пути поиска программ или конфигурации делает скрипт воспроизводимым. Пример настройки пути и запуска утилиты выглядит так:

```
PATH=/usr/local/bin:/usr/bin:/bin ls
```

Подстановки включают замену параметров, арифметические выражения, подстановку команд и разбиение по пробелам после расширений. Чтобы избежать нежелательной разбивки и подстановки имен файлов, используют кавычки. Безопасное отображение переменной с сохранением пробелов выполняется командой:

```
printf '%s\n' "$HOME"
```

Оболочка содержит встроенные команды cd, export, test, eval, а также управляющие конструкции if, case, for, while, until, которые не создают новых процессов и позволяют контролировать выполнение. Внешние команды запускаются через системный вызов создания процесса, а затем заменяются новым исполняемым образом. Потоки ввода и вывода перенаправляются на файлы или каналы. Чтобы записать вывод команды в файл, достаточно выполнить:

```
ls > listing.txt
```

Для передачи данных по цепочке процессов используют конвейер, соединяющий стандартный вывод одной команды со стандартным вводом другой:

```
ps -ef | grep sshd | wc -l
```

Управление дескрипторами позволяет создавать дополнительные каналы или переназначать стандартные. Например, открыть отдельный файл на запись и использовать его внутри скрипта можно так:

```
exec 3>report.log
printf 'hello\n' >&3
```

Когда требуется временное подключение файла к стандартному вводу, используют конструкцию подстановки процесса, доступную в расширенных оболочках, но переносимые сценарии предпочитают явные редиректы. Обработка сигналов критична для надежных сценариев: оболочка прерывает текущую команду по сигналу прерывания, а сценарии устанавливают ловушки, чтобы корректно очищать ресурсы перед завершением:

```
trap 'echo cleanup; rm -f /tmp/lock' EXIT INT TERM
```

Для повышения устойчивости сценариев включают строгие опции, заставляющие завершаться при ошибках, неопределенных переменных и разрыве в конвейере:

```
set -euo pipefail
```

Жизненный цикл запуска внешней команды можно наблюдать через трассировку системных вызовов, а для проверки соответствия переносимому поведению устанавливают переменную, которая включает строгое трактование стандартом:

```
strace -e execve bash -c 'echo hi'
POSIXLY_CORRECT=1 sh script.sh
```

Переносимый стиль требует избегать нестандартных возможностей конкретных реализаций, например массивов, арифметики с плавающей точкой или расширенных шаблонов, если сценарий должен работать на минимальных системах. Управление заданиями позволяет приостанавливать и возобновлять процессы в интерактивной сессии, но в сценариях оно отключено для предсказуемости.

Контроль завершения команд основан на кодах возврата: ноль означает успех, ненулевое значение — ошибку, которую нужно обрабатывать явно. Для проверки структуры сценария и корректности кавычек удобно включать режим трассировки:

```
set -x
```

Понимание того, как оболочка ищет команды в переменной окружения пути, помогает избежать зависимостей от конкретных директорий; список директорий можно просмотреть просто командой, чтобы убедиться в ожидаемом порядке:

```
printf '%s\n' $PATH
```

Важным аспектом является разница между встроенными и внешними командами: встроенные выполняются в том же процессе оболочки и способны менять её состояние, например переменную или текущий каталог, в то время как внешние не могут. Поэтому перенаправления и присваивания перед внешними командами не сохраняют изменения в оболочке. Конвейеры создают несколько процессов, и только последняя команда получает код возврата, если не установлен контроль конвейера, поэтому строгие сценарии используют проверку отдельных сегментов.

Итоговая картина: оболочка — мощный и переносимый инструмент управления процессами, потоками и окружением, и грамотное использование её семантики позволяет строить надежные автоматизации в серверных, контейнерных и встроенных системах, обеспечивая одинаковое поведение на всех платформах, соответствующих стандарту.
