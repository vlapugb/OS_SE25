# Билет: POSIX: shell

## 1. Стандарт POSIX и роль shell

**POSIX (Portable Operating System Interface)** — набор стандартов, определяющих интерфейсы ОС, чтобы программы были переносимыми между Unix‑подобными системами.

Для командной оболочки (shell) POSIX определяет:

- базовый синтаксис командной строки и скриптов;
- обязательный набор встроенных команд;
- поведение конвейеров, перенаправлений, подстановок;
- формат переменных, аргументов, статусов завершения.

**Shell** — это:

- командный интерпретатор (взаимодействие пользователя с ОС);
- язык сценариев (скриптов);
- «клей» между утилитами ОС (ls, grep, sed, awk и др.).

POSIX‑совместимая оболочка обычно доступна как `/bin/sh`.

---

## 2. Виды оболочек и POSIX‑совместимость

Распространённые оболочки:

- **sh** — «классическая» оболочка Bourne shell, прообраз POSIX‑shell.
- **bash** — Bourne Again SHell, расширенная оболочка (много нестандартных возможностей).
- **dash** — минималистичный быстрый POSIX‑shell (часто используется как `/bin/sh` в Linux).
- **ksh** — KornShell, один из предков POSIX‑shell.
- **zsh** — мощная интерактивная оболочка, с большими расширениями.

**Важно:** POSIX определяет поведение «оболочки стандарта POSIX». Многие реальные shell добавляют расширения (arrays в bash, `[[ ]]`, `(( ))`, brace expansion и т.п.), которые **не гарантированы** в чистом POSIX‑/bin/sh.

На экзамене, если тема «POSIX: shell», обычно подразумевают **POSIX‑совместимый `/bin/sh`**, а не конкретно bash.

---

## 3. Жизненный цикл выполнения команды shell

1. **Чтение строки**:
   - ввод с терминала или из файла скрипта.

2. **Разбор (парсинг)**:
   - разделение на токены (слова, операторы `|`, `;`, `&&`, `||`, `>`, `<` и т.д.);
   - учёт кавычек `'...'` и `"..."`, экранирования `\`.

3. **Подстановки (expansions)**:
   В POSIX‑shell порядок примерно такой:
   1. **Tilde‑подстановка**: `~`, `~user` → домашний каталог (может быть не везде по POSIX, зависит от shell).
   2. **Параметр/переменная**: `$VAR`, `${VAR}`.
   3. **Подстановка команд**: `$(команда)` или \`команда\`.
   4. **Арифметическая подстановка**: `$((выражение))` (POSIX включает простую арифметику).
   5. **Разделение по IFS** (Internal Field Separator).
   6. **Глобbing (file name expansion)**: `*`, `?`, `[...]`.

4. **Применение перенаправлений**: `<`, `>`, `>>`, `2>`, `<<` и т.п.

5. **Запуск команды**:
   - если это **встроенная команда** (built‑in) — выполняется внутри shell‑процесса;
   - если это **внешняя программа** — создаётся новый процесс и выполняется программа (поиск через `PATH`).

6. **Получение статуса завершения**:
   - статус доступен в переменной `$?`;
   - по POSIX: **0 — успех**, ненулевое значение — ошибка (тип ошибки зависит от программы).

---

## 4. Типы команд в POSIX shell

### 4.1. Простая команда (simple command)

Пример:

```sh
ls -l /etc
```

Структура: **последовательность слов**, возможно с перенаправлениями.

### 4.2. Составные команды (compound commands)

- **Группы**:
  - Подшелл:

    ```sh
    ( команда1; команда2 )
    ```

    Выполняется в отдельном процессе, изменения переменных снаружи не видны.

  - Группа в текущем shell:

    ```sh
    { команда1; команда2; }
    ```

    Важно: точка с запятой **перед** `}` обязательна.

- **Условные конструкции**: `if`, `case`.
- **Циклы**: `for`, `while`, `until`.

---

## 5. Встроенные и внешние команды

### 5.1. Встроенные (built‑ins) POSIX shell

Чаще всего (список может немного отличаться у разных реализаций):

- `cd` — смена текущего каталога;
- `echo`, `printf` — вывод текста;
- `exec` — заменить текущий shell другим процессом;
- `exit` — завершить shell;
- `export` — сделать переменную переменной окружения;
- `readonly` — сделать переменную только для чтения;
- `set`, `unset` — работа с параметрами shell и переменными;
- `shift` — сдвиг позиционных параметров;
- `times` — время работы процессов;
- `type` / `command` (в зависимости от реализации) — узнать, как будет выполнена команда;
- `.` (dot) — выполнить скрипт в текущем shell (source).

Почему встроенные важны:
- работают без создания нового процесса (быстрее);
- имеют особые права (например, `cd` **должен** менять каталог текущего shell‑процесса).

### 5.2. Внешние команды

Отдельные программы, запускаемые через системный вызов `execve`:

- утилиты: `ls`, `cp`, `mv`, `rm`, `grep`, `sed`, `awk`, `find` и т.д.;
- любые исполняемые файлы в каталогах из `PATH`.

---

## 6. Перенаправление ввода‑вывода

Файловые дескрипторы по умолчанию:

- `0` — stdin (ввод);
- `1` — stdout (обычный вывод);
- `2` — stderr (вывод ошибок).

### 6.1. Основные формы

- Перенаправление вывода (перезаписать файл):

  ```sh
  команда > файл
  # то же, что 1>файл
  ```

- Перенаправление вывода (дописать в конец):

  ```sh
  команда >> файл
  ```

- Перенаправление ошибок:

  ```sh
  команда 2> errors.log
  команда 2>> errors.log
  ```

- Перенаправление ввода из файла:

  ```sh
  команда < input.txt
  # то же, что 0<input.txt
  ```

- Объединение stdout и stderr:

  ```sh
  команда > all.log 2>&1
  ```

  Здесь `2>&1` означает: перенаправить stderr (2) туда же, куда уже направлен stdout (1).

### 6.2. Here‑document (<<)

Позволяет подать «встроенный» текст на stdin команды:

```sh
cat <<EOF
Первая строка
Вторая строка
EOF
```

- `EOF` — произвольный маркер конца;
- ввод читается до строки, совпадающей с маркером.

### 6.3. Примеры

```sh
# запись списка файлов в файл
ls >list.txt

# разделение нормального вывода и ошибок
ls /root /etc 1>ok.log 2>err.log

# использование here‑document
wc -l <<END
one
two
three
END
```

---

## 7. Конвейеры и операторы управления

### 7.1. Конвейер (pipeline) `|`

Передача stdout одной команды на stdin другой:

```sh
ls /etc | grep conf
```

Особенности:

- каждый элемент конвейера — отдельный процесс (кроме возможных встроенных в некоторых реализациях);
- статус конвейера (в POSIX) обычно равен статусу **последней** команды.

### 7.2. Операторы последовательности и условий

- `;` — просто последовательное выполнение:

  ```sh
  команда1; команда2
  ```

- `&` — запуск в фоне:

  ```sh
  команда &
  ```

- `&&` — выполнить вторую команду, **если первая завершилась успешно** (код 0):

  ```sh
  make && make install
  ```

- `||` — выполнить вторую команду, **если первая завершилась с ошибкой** (код ≠ 0):

  ```sh
  make || echo "Сборка не удалась"
  ```

Комбинации:

```sh
команда1 && команда2 || команда3
```

Частый шаблон: «если команда1 прошла, то команда2, иначе команда3».

---

## 8. Переменные и окружение

### 8.1. Переменные shell

Создание и использование:

```sh
VAR=value   # без пробелов вокруг '='
echo "$VAR"
```

По умолчанию — **локальные** переменные shell (не передаются дочерним процессам).

### 8.2. Переменные окружения

Чтобы переменная передавалась запущенным программам:

```sh
export VAR=value   # задать и экспортировать
# или
VAR=value
export VAR
```

Типичные переменные окружения:

- `PATH` — список каталогов для поиска исполняемых файлов (`:`‑разделённый);
- `HOME` — домашний каталог пользователя;
- `SHELL` — путь к оболочке;
- `PWD` — текущий каталог;
- `LANG`, `LC_*` — локаль.

### 8.3. Специальные параметры shell

- `$0` — имя скрипта;
- `$1`, `$2`, … — позиционные параметры;
- `$#` — количество позиционных параметров;
- `$@` — все аргументы раздельно;
- `$*` — все аргументы как одна строка;
- `$?` — статус завершения последней команды;
- `$$` — PID текущего shell;
- `$!` — PID последнего запущенного в фоне процесса.

---

## 9. Скрипты shell: структура и запуск

### 9.1. Shebang и права

Простой скрипт:

```sh
#!/bin/sh
echo "Hello, POSIX shell"
```

Шаги:

1. Сохранить в файл, например `script.sh`.
2. Сделать исполняемым:

   ```sh
   chmod +x script.sh
   ```

3. Запустить:

   ```sh
   ./script.sh
   ```

Либо:

```sh
sh script.sh
```

(без shebang или без флага `+x`).

### 9.2. Опции shell (часто используемые)

- `set -e` — завершать скрипт при ошибке команды (код ≠ 0);
- `set -u` — ошибка при обращении к несуществующей переменной;
- `set -x` — трассировка: вывод выполняемых команд;
- `set -f` — отключить globbing (`*`, `?`).

Комбинация через `set` в скрипте:

```sh
set -eu  # «умеренно строгий» режим
```

(Замечание: некоторые опции формально не входят в POSIX, но часто поддерживаются.)

---

## 10. Условные конструкции и циклы

### 10.1. if / then / elif / else / fi

```sh
if команда; then
    # если команда вернула 0
    ...
elif другая_команда; then
    ...
else
    ...
fi
```

Часто в роли команды используется `test` или `[`:

```sh
if [ -f "$FILE" ]; then
    echo "Файл существует"
fi
```

Основные проверки `test` / `[` (POSIX):

- для файлов:
  - `-f file` — обычный файл;
  - `-d dir` — каталог;
  - `-r`, `-w`, `-x` — права чтения/записи/выполнения;
  - `-s file` — размер > 0.
- строковые:
  - `[ -z "$s" ]` — пустая строка;
  - `[ -n "$s" ]` — непустая строка;
  - `[ "$a" = "$b" ]` — равны;
  - `[ "$a" != "$b" ]` — не равны.
- числовые:
  - `-eq`, `-ne`, `-lt`, `-le`, `-gt`, `-ge`.

### 10.2. case / esac

```sh
case "$var" in
    start)
        echo "Стартуем"
        ;;
    stop)
        echo "Останавливаем"
        ;;
    *)
        echo "Неизвестная команда"
        ;;
esac
```

Удобно для разветвления по строковым шаблонам (поддерживаются glob‑шаблоны `*`, `?`, `[...]`).

### 10.3. Циклы for, while, until

**for:**

```sh
for f in *.txt; do
    echo "Файл: $f"
done
```

**while:**

```sh
while read line; do
    echo "Строка: $line"
done < file.txt
```

**until:** выполняется, пока команда возвращает **ненулевой код**:

```sh
until ping -c1 host >/dev/null 2>&1; do
    echo "Ждём, когда host станет доступен..."
    sleep 1
done
```

`break` — выйти из цикла, `continue` — перейти к следующей итерации.

---

## 11. Работа с процессами и сигналами

### 11.1. Фоновые процессы

- Запуск в фоне:

  ```sh
  команда &
  ```

- Управление (зависит от интерактивного shell):
  - `jobs` — список фоновых задач;
  - `fg` — вернуть задачу на передний план;
  - `bg` — возобновить в фоне.

### 11.2. Сигналы и trap

POSIX‑shell может перехватывать сигналы и выполнять обработчик:

```sh
trap 'echo "Ctrl+C пойман"; exit 1' INT
```

- `INT` — сигнал прерывания (обычно Ctrl+C).
- `trap 'команды' СИГНАЛЫ` — выполнить команды при получении сигнала.

Обработка завершения:

```sh
trap 'echo "Скрипт завершается"; rm -f /tmp/tmpfile' EXIT
```

`EXIT` — псевдосигнал «при выходе из shell».

---

## 12. Отличия POSIX‑shell и расширенных оболочек (bash и др.)

Важно понимать, что **не всё, что работает в bash, является POSIX**.

НЕ POSIX (или не гарантируется):

- массивы вида `arr[0]=value`;
- `[[ ... ]]` вместо `[ ... ]`;
- `(( арифметика ))` в стиле C;
- brace expansion `{1..10}`, `{a,b,c}`;
- многие опции `set` и `shopt`;
- расширенные подстановки `${var//pattern/repl}` и т.п.

Если говорят «написать POSIX‑совместимый скрипт» — значит, нужно:

- использовать только те возможности, которые определены стандартом POSIX;
- тестировать скрипт в «строгом» `/bin/sh` (часто это `dash`).

---

## 13. Краткое резюме

1. POSIX определяет *общий стандарт* для оболочки (syntax + semantics).
2. Shell — командный интерпретатор и язык скриптов.
3. Команда проходит этапы: парсинг → подстановки → перенаправления → запуск → получение статуса.
4. Есть встроенные команды (работают в самом shell) и внешние программы.
5. Перенаправления и конвейеры позволяют строить сложные цепочки обработки данных.
6. Переменные и окружение — основа настройки поведения программ.
7. POSIX shell предоставляет базовые конструкции программирования: условия, циклы, функции, обработку ошибок.
8. Расширенные оболочки (bash, zsh) добавляют много возможностей, но на экзамене по POSIX нужно опираться именно на стандартные возможности `/bin/sh`.
