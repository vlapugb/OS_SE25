# Билет: POSIX — API для работы с файлами. Понятие файлового дескриптора

## 1. Файл в POSIX

В POSIX/Unix **файл** — это абстракция для работы с данными. Файлом может быть:

- обычный файл на диске;
- каталог (directory);
- символьное или блочное устройство (терминал, диск, /dev/null и т.п.);
- канал (pipe), сокет;
- псевдотерминал и др.

Общий принцип: *«всё есть файл»* — любой ресурс, поддерживающий операции чтения/записи, представляется единым интерфейсом.

Работа с файлами в POSIX ведётся через **системные вызовы** (syscalls), в отличие от функций стандартной библиотеки (fopen/fread/fwrite из stdio, которые являются обёртками).

---

## 2. Понятие файлового дескриптора

**Файловый дескриптор (file descriptor, FD)** — это:

- целое неотрицательное число (тип `int`), которое **процесс** использует как «ручку» к открытому файлу;
- индекс в таблице открытых файлов процесса.

Характеристики:

- Дескриптор сам по себе не хранит данных, а указывает на запись в ядре о конкретно открытом объекте (файл, сокет, pipe и т.п.).
- POSIX **не гарантирует** конкретных значений, но по соглашению:
  - `0` — стандартный ввод (stdin),
  - `1` — стандартный вывод (stdout),
  - `2` — поток ошибок (stderr).

Каждый процесс имеет:

1. **Таблицу дескрипторов** (per-process).
2. В ядре есть **таблица открытых файлов** (system-wide open file table), где хранятся:
   - указатель текущей позиции чтения/записи (offset);
   - режим доступа (read/write/append и т.д.);
   - счетчик ссылок (сколько дескрипторов ссылается).

Несколько дескрипторов (даже из разных процессов) могут указывать на один и тот же открытый файл (shared offset и режимы).

---

## 3. Базовые системные вызовы для работы с файлами

### 3.1. `open()` и `creat()`

Прототипы (упрощённо):

```c
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int open(const char *pathname, int flags, ... /* mode_t mode */);
int creat(const char *pathname, mode_t mode); // исторический, сейчас обычно реализован через open()
```

**Результат:**

- при успехе — новый файловый дескриптор (int ≥ 0);
- при ошибке — `-1`, подробнее — в `errno`.

#### Флаги `flags` для `open()` (POSIX):

- Режимы доступа (обязателен один из):
  - `O_RDONLY` — только чтение;
  - `O_WRONLY` — только запись;
  - `O_RDWR` — чтение и запись.

- Дополнительные флаги:
  - `O_CREAT` — создать файл, если не существует (требует аргумент `mode`);
  - `O_EXCL` — использовать только с `O_CREAT`: ошибка, если файл уже есть;
  - `O_TRUNC` — обрезать файл до длины 0 при открытии на запись;
  - `O_APPEND` — запись всегда в конец файла;
  - `O_NONBLOCK` — неблокирующий режим (для pipe/tty/сокетов);
  - `O_SYNC` и др. (синхронная запись).

Пример:

```c
int fd = open("data.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd == -1) {
    // обработка ошибки
}
```

Здесь `0644` — права доступа (восьмеричное число: rw-r--r--).

**`creat()`** — исторический вызов:

```c
int fd = creat("file.txt", 0666);
// эквивалентно: open("file.txt", O_WRONLY | O_CREAT | O_TRUNC, 0666);
```

---

### 3.2. `close()`

```c
#include <unistd.h>

int close(int fd);
```

- Закрывает открытый файл/ресурс, освобождает дескриптор.
- При успехе — `0`, при ошибке — `-1`.
- После `close(fd)` использовать этот дескриптор **нельзя** (U.B. при обращении).
- Закрытие происходит автоматически при завершении процесса, но **явно закрывать** — хорошая практика (ограниченное количество дескрипторов).

---

### 3.3. `read()` и `write()`

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

- `read`:
  - читает до `count` байт из файла `fd` в буфер `buf`;
  - возвращает:
    - `> 0` — количество реально прочитанных байт;
    - `0` — конец файла (EOF);
    - `-1` — ошибка, деталь в `errno`.

- `write`:
  - записывает до `count` байт из `buf` в файл `fd`;
  - возвращает:
    - `>= 0` — число реально записанных байт (может быть меньше `count`);
    - `-1` — ошибка.

Особенности:

- `read`/`write` могут прочитать/записать **меньше** запрошенного количества байт, особенно:
  - при работе с неблокирующими дескрипторами;
  - при работе с сокетами, pipe.
- Для обычных файлов на диске `write` часто записывает всё сразу, но POSIX этого **не гарантирует**.

---

### 3.4. `lseek()` — изменение позиции в файле

```c
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

- Меняет текущую позицию (offset) в открытом файле:
  - `whence`:
    - `SEEK_SET` — от начала файла;
    - `SEEK_CUR` — от текущей позиции;
    - `SEEK_END` — от конца файла.
- Возвращает новую позицию при успехе, `-1` при ошибке.
- Применим только к файлам, поддерживающим позиционирование:
  - нельзя (или частично нельзя) использовать для pipe, сокетов, терминалов (ошибка `ESPIPE`).

Пример:

```c
off_t size = lseek(fd, 0, SEEK_END); // определить размер файла
lseek(fd, 0, SEEK_SET);              // вернуться в начало
```

---

## 4. Таблица дескрипторов, наследование и копирование

### 4.1. Таблица дескрипторов процесса

Внутри процесса у каждой записи таблицы:

- номер дескриптора (индекс);
- указатель на структуру «открытый файл» в ядре;
- флаги на уровне дескриптора (например, `FD_CLOEXEC`).

При вызове `open()`:

- ядро выделяет запись в системной таблице открытых файлов;
- находит минимальный свободный номер дескриптора процесса;
- соединяет их.

При `close()`:

- запись дескриптора в процессе помечается свободной;
- уменьшается счётчик ссылок в системной структуре.

---

### 4.2. Наследование дескрипторов при `fork()`

При `fork()`:

- создаётся новый процесс (child);
- таблица дескрипторов **копируется**:
  - в родителе и потомке дескрипторы имеют одинаковые номера;
  - оба указывают на одни и те же записи в системной таблице;
  - текущая позиция в файле (offset) — **общая**.

Следствия:

- запись в одном процессе изменяет позицию для другого (если они разделяют одну запись).
- часто используется для организации конвейеров, перенаправлений, работы с pipe.

---

### 4.3. Копирование дескрипторов: `dup()` и `dup2()`

```c
#include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);
```

- `dup(oldfd)`:
  - находит **минимальный свободный** номер дескриптора;
  - делает его копией `oldfd` (общий открытый файл, общий offset);
  - возвращает новый номер.

- `dup2(oldfd, newfd)`:
  - делает так, чтобы `newfd` стал копией `oldfd`:
    - если `newfd` уже открыт — сначала закрывается;
    - если `oldfd == newfd` — ничего не делает, возвращает `newfd`.

Пример перенаправления вывода (низкоуровневый):

```c
int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd, 1);  // теперь stdout (fd=1) указывает на output.txt
close(fd);
// printf/puts и т.п. будут писать в файл
```

---

## 5. Дополнительные системные вызовы и настройки

### 5.1. `fcntl()` — управление дескрипторами

```c
#include <fcntl.h>

int fcntl(int fd, int cmd, ...);
```

Некоторые полезные команды:

- `F_GETFL` / `F_SETFL` — получить/установить флаги файла (например, `O_NONBLOCK`);
- `F_GETFD` / `F_SETFD` — получить/установить флаги дескриптора (например, `FD_CLOEXEC`);
- `F_DUPFD` — создать новый дескриптор (похож на `dup`, но с минимальным значением не меньше заданного).

Флаг `FD_CLOEXEC`:

- если установлен, при вызове `exec()` дескриптор будет автоматически закрыт;
- используется, чтобы «лишние» дескрипторы не утекали в новые процессы.

---

### 5.2. `fsync()` и `fdatasync()`

```c
#include <unistd.h>

int fsync(int fd);
```

- Гарантирует запись данных на диск (сброс кэша ядра для этого файла).
- Важно для надёжности (БД, журналы, транзакции).

---

### 5.3. Выборочное закрытие: `closefrom()` (не POSIX, но встречается)

Некоторые системы предоставляют `closefrom(int lowfd)` — закрыть все дескрипторы ≥ `lowfd`. Это не часть стандарта POSIX, но полезно понимать идею: дескрипторов может быть много, и ими надо управлять.

---

## 6. Стандартные дескрипторы: stdin, stdout, stderr

Соглашение:

- `0` — стандартный ввод (обычно клавиатура или перенаправление/pipe);
- `1` — стандартный вывод;
- `2` — поток ошибок (обычно терминал, даже если stdout перенаправлен).

Используются в C-функциях:

- `stdin`, `stdout`, `stderr` — это **потоки stdio**, привязанные к FD 0, 1, 2 соответственно.

Примеры системных вызовов:

```c
write(1, "Hello
", 6);      // вывод в stdout
read(0, buf, sizeof(buf));  // чтение с stdin
```

Shell-перенаправления (`>`, `<`, `2>`, `|`) внутри себя оперируют теми же дескрипторами.

---

## 7. Ошибки и `errno`

При ошибке большинство файловых системных вызовов возвращают `-1` и устанавливают переменную `errno` (thread-local), например:

- `EACCES` — нет прав доступа;
- `ENOENT` — файл не существует;
- `EBADF` — невалидный дескриптор (например, уже закрыт);
- `EMFILE` — процесс превысил лимит открытых файлов;
- `ENFILE` — системный лимит на количество открытых файлов;
- `EINTR` — вызов прерван сигналом;
- `EAGAIN`/`EWOULDBLOCK` — неблокирующий дескриптор не готов.

Пример обработки:

```c
#include <errno.h>
#include <string.h>
#include <stdio.h>

int fd = open("file.txt", O_RDONLY);
if (fd == -1) {
    fprintf(stderr, "open error: %s
", strerror(errno));
}
```

---

## 8. Буферизация: syscalls vs stdio

Важно отличать:

- **Системные вызовы**: `open`, `read`, `write`, `close` — работают напрямую с ядром, без буферизации в user space.
- **Функции stdio**: `fopen`, `fread`, `fwrite`, `fprintf` и т.п. — используют **буферизацию в пользовательском пространстве** и внутри себя вызывают `read`/`write`.

Следствия:

- Нельзя безопасно «смешивать» низкоуровневый `read/write` и высокоуровневый `fread/fwrite` на одном и том же файловом дескрипторе без аккуратной синхронизации — можно нарушить внутренние буферы stdio.
- При необходимости работать и с тем, и с другим — обычно открывают файл через `open`, затем создают `FILE *` через `fdopen`, или наоборот.

---

## 9. Связь дескрипторов с файловой системой

Открытие файла в POSIX включает несколько этапов:

1. Ядро по пути `pathname` находит соответствующий **inode** (индексный дескриптор в файловой системе).
2. Проверяет права доступа (uid/gid процесса, биты разрешений, ACL и т.п.).
3. Создаёт запись в системной таблице открытых файлов:
   - указатель на inode;
   - текущая позиция (offset);
   - режим;
   - счётчики.
4. Добавляет запись в таблицу дескрипторов процесса, присваивая FD.

Удаление файла через `unlink()`:

```c
#include <unistd.h>
int unlink(const char *pathname);
```

- удаляет **имя** (link) из каталога;
- сам объект файла удаляется только когда:
  - его link count становится 0, **и**
  - нет открытых дескрипторов, ссылающихся на него.

Это позволяет:

- «удалить» файл, но продолжать его использовать, пока открыт дескриптор (часто используется для временных файлов).

---

## 10. Краткое резюме

1. **Файловый дескриптор** — целое число, которое процесс использует для доступа к открытому файлу/ресурсу.
2. Каждый процесс имеет таблицу дескрипторов, а ядро — таблицу открытых файлов, где хранятся режимы и позиция.
3. Основные системные вызовы POSIX-файлового API:
   - `open`/`creat` — открыть/создать файл;
   - `close` — закрыть;
   - `read`/`write` — чтение/запись;
   - `lseek` — изменить позицию;
   - `dup`/`dup2` — копировать дескрипторы;
   - `fcntl` — управление флагами;
   - `fsync` — сброс на диск;
   - `unlink` — удаление имени файла.
4. Дескрипторы наследуются при `fork()`, используются для перенаправлений, pipe, работы с устройствами.
5. Стандартные дескрипторы 0/1/2 — stdin/stdout/stderr — используются всей пользовательской средой.
6. Корректное управление дескрипторами (своевременное закрытие, проверка ошибок, учёт наследования) — ключ к надёжным и безопасным программам в POSIX-системах.
