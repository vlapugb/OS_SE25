# POSIX: API для работы с файлами. Понятие файлового дескриптора

Программный интерфейс приложения для работы с файлами в переносимой системе основан на системных вызовах, которые управляют созданием, открытием, чтением, записью, управлением смещением и закрытием потоков байтов, связанных с объектами файловой системы. Центральное понятие — файловый дескриптор, то есть целое число, которое индексирует запись в таблице открытых файлов процесса. Эта запись содержит указатель на объект ядра с описанием inode, текущего смещения, флагов доступа и счетчика ссылок, поэтому операции чтения и записи используют дескриптор, не обращаясь снова к имени файла.

Вызов открытия принимает путь, набор флагов и маску прав, формируя связь между именем и дескриптором. Расширенная форма открытия относительно каталога позволяет оперировать путями без смены текущего каталога и уменьшает вероятность атак через подмену пути. Наблюдать, как процесс открывает и читает файл, помогает трассировка:

```
strace -e trace=openat,read,write,close cat sample.txt
```

Флаги открытия задают режимы: только чтение, только запись, чтение-запись, создание, эксклюзивное создание, добавление в конец, неблокирующий доступ, синхронную запись данных или метаданных. Маска прав применяется только при создании и комбинируется с маской процесса, определяющей, какие биты будут сброшены. После успешного открытия операции чтения и записи работают с байтовым потоком: чтение возвращает количество байтов или ноль при достижении конца файла, запись возвращает количество записанных байтов, которое может быть меньше запрошенного при ошибках или сигналах. Для чтения или записи по конкретному смещению без изменения глобального курсора используют операции ввода-вывода с указанием позиции, что позволяет работать с несколькими потоками в одном файле без гонок за смещение.

Управление смещением выполняется вызовом, который переносит позицию относительно начала, текущей позиции или конца файла и возвращает новое значение, а проверка текущей позиции помогает координировать доступ. Атомарность добавления достигается флагом append: ядро перемещает смещение в конец и записывает данные как одну операцию, предотвращая перемешивание байтов между процессами. Узнать атрибуты файла — размер, временные метки, права, количество ссылок — можно вызовом запроса статуса, который позволяет принимать решения о правах или изменениях:

```
stat sample.txt
```

Работа с правами включает установку владельца и группы, изменение прав доступа и управление маской создания через вызов установки умаска. Важна наследуемость дескрипторов: при создании нового процесса таблица открытых файлов копируется, поэтому без флага закрытия при выполнении новая программа унаследует дескрипторы, что может приводить к утечке ресурсов. Чтобы предотвратить наследование временного файла или сокета, включают флаг закрытия при выполнении или используют соответствующую опцию открытия. Пример установки флага через универсальный язык:

```
perl -MPOSIX -e 'open my $fh,">",q(/tmp/demo); fcntl $fh, F_SETFD, FD_CLOEXEC'
```

Дублирование дескрипторов позволяет перенаправлять стандартные потоки, создавать дополнительные представления одного и того же файла и использовать их в конвейерах или дочерних процессах. Просмотр текущих дескрипторов процесса доступен через псевдофайловую систему, что помогает диагностировать, какие файлы остаются открытыми:

```
ls -l /proc/$$/fd
```

Существуют неблокирующие режимы ввода-вывода и уведомления через селекторы событий, которые позволяют строить высокопроизводительные серверы, минимизируя количество потоков. При ошибках системные вызовы возвращают отрицательные коды, а детали содержатся в глобальной переменной ошибок, которую нужно проверять и обрабатывать, учитывая временные состояния, например временную недоступность ресурса или прерывание сигналом.

Закрытие дескриптора уменьшает счетчик ссылок в объекте ядра, и если это последняя ссылка, ресурсы освобождаются и буферы сбрасываются на диск. Разработчик должен учитывать, что закрытие стандартных потоков может влиять на поведение библиотек ввода-вывода, поэтому явное управление жизненным циклом файлов важно для надежности.

В итоге файловый интерфейс в переносимой системе представляет собой минимальный, но выразительный набор примитивов: открытие с точными флагами, чтение и запись с контролем смещения, управление правами и наследованием дескрипторов, что позволяет строить предсказуемые и переносимые приложения на любом уровне — от утилиты до серверной системы.
