# Динамически разделяемые библиотеки

Динамически разделяемая библиотека — это объектный файл в формате Executable and Linkable Format с расширением .so, загружаемый во время запуска процесса или по требованию в момент вызова функции, что позволяет нескольким процессам разделять один экземпляр кода и обновлять библиотеку без пересборки приложений. В отличие от статической библиотеки, которая просто архив объектных файлов, динамическая содержит таблицу динамических символов, описания зависимостей, версионные секции и информацию для динамического загрузчика, расположенного обычно в каталоге /lib64 или /lib и отвечающего за размещение библиотек в адресном пространстве. Чтобы такая библиотека могла быть размещена по произвольному адресу, компилятор генерирует позиционно независимый код, называемый Position Independent Code, что достигается флагом создания относительных обращений к данным и таблицам символов.

Последовательность сборки включает компиляцию модулей с поддержкой позиционной независимости, затем линковку в общий объект с указанием имени совместного использования, называемого soname, и наконец создание удобных симлинков. Типичный цикл выглядит так:

```
cc -O2 -fPIC -c api.c helpers.c plugin.c
cc -shared -Wl,-soname,libsample.so.2 -o libsample.so.2.3 api.o helpers.o plugin.o
ln -sf libsample.so.2.3 libsample.so
```

Проверка динамического раздела, где перечислены зависимости и пути поиска, выполняется через анализ, а список экспортируемых символов можно увидеть отдельной командой:

```
readelf -d libsample.so.2.3
nm -D libsample.so.2.3
```

Когда исполняемый файл ссылается на такую библиотеку, динамический загрузчик ищет ее в каталогах, прошитых в заголовке исполняемого файла через записи пути загрузки, затем в системных путях, закодированных в самом загрузчике, и дополнительно учитывает переменную окружения LD_LIBRARY_PATH. Для диагностики реального поиска и выбора версий полезно включать отладку загрузчика, а для быстрой проверки разрешения зависимостей достаточно стандартной команды:

```
LD_DEBUG=libs,symbols ./app
ldd ./app
```

Благодаря динамическим библиотекам обновление безопасности становится проще: достаточно установить новую версию файла и обновить кэш путей командой администратора, которая перечитывает конфигурацию каталогов из /etc/ld.so.conf.d и создает симлинки и кэш:

```
sudo ldconfig
```

Чтобы упаковать приложение вместе с библиотеками без установки в систему, используют относительный путь $ORIGIN, означающий каталог исполняемого файла, и задают его в списке путей. Теперь бинарник находит библиотеку в подкаталоге рядом с собой, избегая конфликтов версий:

```
cc main.c -L./lib -Wl,-rpath,'$ORIGIN/lib' -lsample -o app
```

Динамическая загрузка также поддерживает позднее связывание: вызовы функций направляются через таблицу процедурных переходов, а адреса хранятся в глобальной таблице смещений, заполняемой при первом обращении. Отключить ленивое связывание и выполнить все релокации заранее можно переменной окружения, что полезно для измерения производительности или повышения безопасности:

```
LD_BIND_NOW=1 ./app
```

В отличие от статического подхода, динамические библиотеки позволяют переопределять символы, подменяя поведение программы без перекомпиляции, например через механизм предварительной загрузки, который применяется для профилирования, тестирования и песочниц, но требует осторожности, потому что ломает ожидания о версиях символов:

```
LD_PRELOAD=./libtrace.so ./app
```

Версионирование символов внутри библиотеки позволяет совместить несколько реализаций одной функции, сохранив обратную совместимость для старых бинарников; посмотреть версии можно командой:

```
objdump -T libsample.so.2.3 | grep '@'
```

При проектировании библиотеки важно следить за стабильностью интерфейса: двоичный интерфейс меняется при изменении размеров структур, соглашений о вызовах или макетов таблиц виртуальных функций, и такие изменения требуют инкремента номера имени совместного использования. В окружениях с жесткими требованиями к размеру образа динамические библиотеки уменьшают дублирование кода и позволяют системе хранить одну копию в файловом кеше, а процессы разделяют страницы только для чтения, снижая расход памяти. Но за это приходится платить возможными проблемами несовместимости и необходимостью наличия динамического загрузчика и базовых библиотек на целевой системе. Задача архитектора — подобрать конфигурацию путей, политики поиска и версионирования так, чтобы обеспечить и обновляемость, и стабильность поведения на всех средах, включая контейнеры, виртуальные машины и bare metal.
