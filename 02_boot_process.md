# Шаги загрузки операционной системы

## 1. Общее представление о процессе загрузки

**Загрузка операционной системы (boot process)** — это последовательность шагов, которые выполняет компьютер от момента включения питания до появления рабочей среды пользователя (графический интерфейс или командная строка).

Условно процесс можно разделить на уровни:

1. Аппаратный уровень (питание, процессор, память, устройства).
2. Низкоуровневое программное обеспечение:
   - BIOS или UEFI (прошивка на материнской плате);
   - начальный загрузчик.
3. Загрузчик ОС (bootloader), например GRUB.
4. Загрузка ядра ОС и начальной файловой системы (initramfs/initrd).
5. Инициализация пользовательского пространства (systemd, init, службы).
6. Запуск пользовательской сессии (графический дисплейный менеджер или текстовая консоль).

---

## 2. Включение питания и начальная инициализация (аппаратный уровень)

### 2.1. Подача питания

При нажатии кнопки включения:
- блок питания подаёт стабильное напряжение на компоненты;
- материнская плата поднимает сигналы «готовности» (Power Good);
- сбрасывается (reset) процессор.

После этого:
- процессор начинает выполнение инструкций **с фиксированного адреса**, указывающего на код, расположенный в постоянной памяти (ROM/Flash) на материнской плате — это BIOS или UEFI.

---

## 3. BIOS / UEFI: роль и шаги

### 3.1. BIOS (Basic Input/Output System)

Исторический вариант прошивки:
- хранятся в ПЗУ;
- запускаются первыми;
- обеспечивают:
  - начальную инициализацию оборудования;
  - проверку памяти и устройств;
  - поиск загрузочного устройства.

### 3.2. UEFI (Unified Extensible Firmware Interface)

Современный стандарт:
- более гибкий и расширяемый, чем классический BIOS;
- поддерживает:
  - графический интерфейс;
  - загрузку с больших дисков (GPT);
  - безопасную загрузку (Secure Boot).

### 3.3. POST — Power-On Self Test

**POST** — это самотестирование при включении питания:
- проверка:
  - оперативной памяти (RAM);
  - процессора;
  - базовых контроллеров (клавиатура, видео);
  - минимальных устройств хранения.
- При ошибках:
  - подаются звуковые сигналы (beep-коды);
  - отображаются сообщения об ошибках.

### 3.4. Инициализация оборудования

После POST прошивка:
- настраивает:
  - контроллеры памяти;
  - контроллеры ввода/вывода;
  - шину PCI/PCIe, USB, SATA и др.
- готовит систему к дальнейшей загрузке.

### 3.5. Выбор загрузочного устройства

BIOS/UEFI анализирует:
- список устройств в порядке загрузки (boot order), заданный в настройках:
  - HDD/SSD;
  - CD/DVD;
  - USB-носители;
  - сеть (PXE) и др.

Далее:
- для BIOS — ищется **загрузочный сектор (MBR)** на диске;
- для UEFI — ищется **загрузочный файл EFI** на специализированном разделе (EFI System Partition, обычно FAT32).

---

## 4. Загрузочный сектор и начальный загрузчик (BIOS + MBR)

### 4.1. MBR (Master Boot Record)

Для классической BIOS-схемы:
- Первый сектор диска (512 байт) — это MBR:
  - содержит:
    - таблицу разделов (старого формата);
    - небольшой кусок кода начальной загрузки.

Алгоритм:
1. BIOS читает MBR в память и передаёт ему управление.
2. Код MBR:
   - определяет активный раздел;
   - загружает его загрузочный сектор (Volume Boot Record);
   - передаёт управление следующему коду.

### 4.2. Ограничения MBR

- Очень маленький объём кода (несколько сотен байтов).
- Поэтому сложные загрузчики (GRUB и др.) обычно загружаются **в несколько стадий**:
  - первая стадия — в MBR и ближайшие сектора;
  - последующие — уже из файловой системы раздела.

---

## 5. Загрузка через UEFI

### 5.1. EFI System Partition

При UEFI:
- на диске используется разметка GPT (GUID Partition Table);
- есть специальный раздел **EFI System Partition (ESP)**:
  - формат FAT32;
  - содержит каталог `EFI/` с загрузочными файлами (`.efi`) для разных ОС.

### 5.2. Загрузочные файлы EFI

UEFI:
- напрямую читает файловую систему EFI-раздела;
- находит и запускает указанный **EFI-загрузчик**, например:
  - `EFI/Boot/bootx64.efi` (по умолчанию);
  - `EFI/GRUB/grubx64.efi` или аналогичный.

Таким образом:
- роль «MBR-кода» выполняет прошивка UEFI, которая сразу запускает полноценный загрузчик в виде файла.

---

## 6. Загрузчик операционной системы (bootloader)

### 6.1. Назначение загрузчика

**Загрузчик ОС** — это программа, которая:
- загружается первым с диска (после BIOS/UEFI);
- обеспечивает:
  - выбор ОС (если несколько);
  - передачу параметров ядру;
  - загрузку ядра и начальной файловой системы;
  - (при необходимости) дополнительные функции: пароль, консоль, скрипты.

Примеры загрузчиков:
- GRUB (GRUB2) — массово используется в Linux;
- LILO (устаревший);
- Syslinux/ISOLINUX;
- Windows Boot Manager (Windows Boot Loader).
- rEFInd, rEFIt — EFI-меню для выбора ОС;
- U-Boot — типичный выбор для встраиваемых платформ;
- NTLDR/Bootmgr — ранние загрузчики Windows.

### 6.2. GRUB как пример

GRUB обычно работает в несколько стадий:
1. **Первая стадия** — минимальный код, расположенный в MBR или в EFI-загрузчике.
2. **Вторая стадия** — основной модуль:
   - умеет читать файловую систему;
   - загружает конфигурационный файл (например, `/boot/grub/grub.cfg`);
   - показывает меню выбора ОС.
3. По выбору пользователя:
   - загружает в память ядро ОС (например, `vmlinuz-...`);
   - загружает initramfs (если есть);
   - передаёт управление ядру.

Загрузчик также может:
- передавать ядру параметры командной строки:
  - например, `root=/dev/sda1`, `ro`, `single` и др.

### 6.3. Ограничения ранних стадий и отладочный вывод

BIOS и первая ступень загрузчика работают в очень скромных объёмах памяти (десятки–сотни килобайт), поэтому содержат только минимальный код для перехода к следующему этапу. Пока драйверы не инициализированы, используется самый простой вывод — например, запись в виртуальный порт типа virtio-console или базовые BIOS‑рутину для печати символов.

---

## 7. Загрузка ядра операционной системы

### 7.1. Загрузка ядра

Когда загрузчик выбрал ОС:
- он загружает файл **ядра** в память:
  - в Linux — обычно файл с именем вида `vmlinuz-...` в каталоге `/boot`;
  - в Windows — ядро (`ntoskrnl.exe`) запускается через свой загрузчик.

### 7.2. Инициализация ядра

После получения управления ядро:
1. Переводит процессор в нужный режим (например, защищённый режим, long mode для 64-бит).
2. Настраивает:
   - управление памятью:
     - страничную организацию;
     - таблицы страниц;
   - обработчики прерываний и исключений;
   - драйверы низкоуровневых устройств (таймер, контроллер прерываний).
3. Определяет доступное:
   - количество оперативной памяти;
   - основные устройства (шины, контроллеры).

### 7.3. Initramfs / initrd

Часто ядро использует **начальную RAM-файловую систему**:
- `initrd` (initial ramdisk) или `initramfs`:
  - небольшой образ файловой системы, загружаемый в память;
  - содержит минимальный набор драйверов и утилит.

Назначение:
- обеспечить доступ к корневой файловой системе:
  - например, если нужна специфичная файловая система (LVM, RAID, шифрование);
  - если root-файл-система на другом устройстве или по сети.
- Процесс:
  1. Ядро монтирует initramfs как временную root FS.
  2. Выполняется специальная программа (обычно скрипты, `init` внутри initramfs).
  3. Настраиваются устройства, монтируется настоящая корневая FS (`/`).
  4. Система переключается (`switch_root`) на настоящую root FS и продолжает загрузку.

---

## 8. Запуск процесса инициализации (init / systemd)

### 8.1. Первый процесс в пользовательском пространстве

После того как:
- ядро инициализировало устройства;
- смонтировало корневую файловую систему;

оно запускает **первый процесс в пользовательском пространстве**:
- традиционно: `/sbin/init`;
- в современных Linux — обычно это **systemd** (`/lib/systemd/systemd`).

Этот процесс:
- получает PID = 1;
- становится **родительским** для всех остальных процессов;
- отвечает за дальнейшую инициализацию системы.

### 8.2. Классический init (SysV init)

Исторический вариант:
- запускает скрипты из `/etc/rc.d`, `/etc/init.d` в зависимости от **runlevel** (уровня выполнения);
- последовательно поднимает сервисы: сети, демоны, графическую оболочку и др.

Runlevel (пример для классической схемы):
- 0 — выключение;
- 1 — однопользовательский режим;
- 3 — многопользовательский режим без графики;
- 5 — многопользовательский режим с графикой;
- 6 — перезагрузка.

### 8.3. systemd (современный подход)

В современных Linux-дистрибутивах:
- вместо SysV init часто используется systemd.

Функции systemd:
- параллельный запуск служб;
- управление зависимостями между сервисами;
- контроль и рестарт служб;
- единый журнал (journald).

**Targets** (аналог runlevel):
- multi-user.target — многопользовательский режим;
- graphical.target — графический режим и т.д.

systemd:
1. Монтирует дополнительные файловые системы (`/proc`, `/sys`, `/run`, `/var`, и др.).
2. Запускает:
   - службы (network, cron, sshd, и т.д.);
   - логин-сервисы (`getty`) на виртуальных консолях;
   - дисплейный менеджер (gdm, sddm и т.п.) для графического входа.

---

### 8.4. Другие init-системы

Помимо классических SysV init и systemd, в Linux встречаются:
- OpenRC, runit, s6 — минималистичные системы инициализации;
- Upstart (устаревающий предшественник systemd);
- sysvinit как совместимый базовый вариант.

## 9. Запуск пользовательской сессии

### 9.1. Текстовый режим

Если система настроена на текстовый режим:
- systemd или init запускает:
  - процессы `getty` на терминалах (`tty1`, `tty2`, …);
- пользователь видит:
  - приглашение для ввода логина;
- после успешного входа:
  - запускается оболочка (например, `bash`);
  - пользователь получает консольную сессию.

### 9.2. Графический режим

Если активен графический target:
- запускается **дисплейный менеджер**:
  - `gdm`, `lightdm`, `sddm` и т.п.;
- пользователь:
  - видит окно входа в систему;
  - выбирает пользователя и вводит пароль;
- после аутентификации:
  - запускается **графическая сессия**:
    - оконный менеджер или окружение рабочего стола (GNOME, KDE, Xfce и др.);
  - открываются панели, меню, рабочий стол.

На этом этапе можно считать, что **загрузка ОС завершена**, и пользователь может работать с системой.

---

## 10. Краткий конспект (для запоминания)

1. **Включение питания:**
   - подача напряжения, сброс процессора;
   - CPU начинает выполнение кода из ROM (BIOS/UEFI).

2. **BIOS/UEFI:**
   - POST — проверка оборудования;
   - инициализация устройств;
   - выбор загрузочного устройства;
   - BIOS → загрузка MBR;
   - UEFI → загрузка EFI-файла с ESP.

3. **Начальный загрузчик:**
   - при BIOS:
     - код в MBR, затем загрузочный сектор раздела;
   - ограничен по размеру, поэтому часто только передаёт управление более сложному загрузчику (например, GRUB).

4. **Загрузчик ОС (bootloader):**
   - показывают меню выбора ОС;
   - загружает ядро и initramfs в память;
   - передаёт управление ядру, передавая параметры командной строки.

5. **Ядро ОС:**
   - переводит процессор в нужный режим;
   - настраивает управление памятью, прерывания;
   - обнаруживает устройства;
   - монтирует временную файловую систему (initramfs) при необходимости;
   - затем монтирует корневую файловую систему.

6. **Init / systemd:**
   - ядро запускает первый процесс user-space (PID 1);
   - init/systemd:
     - монтирует дополнительные файловые системы;
     - запускает службы и демоны;
     - настраивает сеть;
     - подготавливает пользовательскую среду.

7. **Пользовательская сессия:**
   - в текстовом режиме — запуск getty и login, затем оболочки;
   - в графическом режиме — запуск дисплейного менеджера и рабочего стола.

Этот конспект можно использовать как развёрнутый ответ на экзаменационный билет  
**«Шаги загрузки операционной системы»**.
